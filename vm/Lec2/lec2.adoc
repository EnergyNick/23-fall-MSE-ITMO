== Lisp ==

=== Раскрутка компилятора ===

Компилятор С написан на C. Пишем новую версию, компилируем.

Компиляторы других языков на С писать труднее (типы данных, чистые функции, исключение и проч. придется как-то обрабатывать. возможно, с потерей). Это не раскрутка.

=== Раскрутка компилятора ===

Есть интерпретатор версии 1, хотим версию 2. На языке С мы его не писали.

Пишем на инт1 компилятор инт2, который порождает следующую версию интерпретатора. Это не компилятор с языка, а компилятор конкретной программы. Для трансформирования текущей версии в следующую.

=== Раскрутка ВМ ===

У вм кроме интерпретатора есть еще и состояние. Его можно загружать и т.д. Нужна штука, которая будет транслировать состояние. Это тоже тяжело назвать компилятором.

=== Metacircular evaluator ===
Интерпертатор порождает интерпретатор нового уровня. При этом они оба могут использовать одни и те же библиотеки.

=== Инкрементальное интерактивное программирование ===
Можно в рабочую систему вносить изменения находу, без перезапуска и т.д. Оно сразу применится.

== BCPL ==

== Forth ==
Имеет интерпретатор скомпилированного кода.

До сих пор жив, программирует космолеты.

Нельзя загрузить из файла. Можно только писать и потом сохранять/ загружать состояние. И изменять его (инкеремнтальность)

== Pascal / P-Code ==

Переносимые библиотеки в виртуальном коде -- библиотеки, которые исполняются на любом интерпретаторе. 

== Smalltalk ==
Алан Кей

Минимализм: есть только объекты, сообщения, классы и наследования. Все управление реализовано через посылку сообщений.

Тоже инкрементальность и рефлексия. Можно сохранять / загружать состояние среды.

Трудно эффективно реализовать: блоки в куче, а не на стеке (т.к. можем возвращаться произвольно куда). Там честно реализованы лямбды, без захвата переменных. (как в  JS)

Когда вызываем метод, адрес его вызова нужно искать в словарях (он динамический). Поэтому оптимизируем с помощью кеширования.

Динамическая компиляция -- нет фазы компиляции, оно компилируется автоматически во время написания кода.

Микрокод -- не инструкции процессора, а уровень ниже.

== Self ==
динамический 

минимализм: объекты, слоты (поля чтения-записи и т.д., методы), сообщения (вызвать реакцию, ассоциированную со слотом), делегирование (если слота нет - передать кому-то сообщение). Всего 8 инструкций ВМ

делегирование -- наследование клонированием

сборка мусора поколениями

спекулятивные оптимизации -- на основе статистики (частино используется в JS)

== Java == 
статический 

Спецификация 

Верификация виртуального кода до выполнения

image::media/jvm.png[]

Ромизация -- сборка под другую платформу

Бинарная конверсия -- классы в бинарник

Целевая компиляция ВМ в текст для С для разных платформ

== OpenJDK ==
генерирует машинный код интерпретатора при КАЖДОМ СТАРТЕ ВМ

это очень быстро, большую часть веремни загрузки занимает инициализация классов