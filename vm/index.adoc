:toc:
:lang: ru-RU
:source-highlighter: rouge
:stem: asciimath

= Ответы к экзамену по с/к "Виртуальные машины", 2023-2024

image::media/2024-01-15-16-19-41.png[]

== Интерпретация
=== 1.1. Интерпретация. Виды интерпретаторов. Компоненты итеративного интерпретатора.

==== Интерпретация
#Интерпретация# – это механизм непосредственного исполнения отдельных
языковых элементов (строк, лексем, команд) программ

Исходный текст высокоуровневых программ на ВМ компилируется (мб неявной динамической) в промежуточное представление (#ПП#)

#Форматы кода#
* Распространяемый формат 
** Стандартизован
** Машинно-независим
** Расширяем
** Компактен
** Пример: `.jar` файлы `Java` (архивы с бинарными class файлами)
** Может содержать медиа ресурсы
* Выполняемый формат -- представление кода в памяти VM
** Порождается из распространяемого формата после его конверсии: загрузки, линковки и верификации
** Может дополнять или замещать распространяемый 
** Преобразования мб статически (отдельная стадия) или динамически (в рантайм)
** Преобразование производится не обязательно локально

==== Виды интерпретаторов
[cols="1,2,2"]
|===
|Интерпретатор
|Рекурсивный
|Итеративный


|Выполнение
|Обходит код, рекурсивно вызывая себя
|Перебирает инструкции последовательно в цикле

|Вызов подпрограммы
|вызывает себя c подпрограммой и параметрами её вызова
| формирует новую секцию в стеке вызовов, меняет указатель текущей инструкции, продолжает выполнение цикла

|Параметры и результаты передаются…
|… непосредственно при вызове 
|… в виртуальных регистрах или на стеке операндов

|Применяется для ПП в виде…
|…текста, деревьев или графа
|…потока, последовательности или массива инструкций (линейных кодов)
|===

==== Компоненты итеративного интерпретатора

* Набор инструкций
** add, load, branch... (может быть расширяемым)
* Виртуальные регистры
** ip — адрес текущей инструкции
** sp — указатель стека
** fp — адрес текущей рамки стека вызовов
* Стеки
** Стек вызовов для организации вызовов
подпрограмм, обычно состоит из
рамок/секций/записей активации
** Стек операндов для передачи параметров и выдачи
результатов виртуальных инструкций (может быть
частью стека вызовов или вообще отсутствовать)
* Цикл интерпретатора
** декодер инструкций и их реализация

=== 1.2. Представление виртуальных инструкций. Передача параметров инструкциям.
==== Представление виртуальных инструкций. 
===== #Токен# 
** Целое число, однозначно идентифицирующее
инструкцию и, возможно, все или некоторые из ее
операндов
** Остальные операнды могут быть закодированы в
потоке инструкций вслед за токеном
** Токены не зависимы от аппаратуры и размещения
кода в памяти
** Пример: байтовые коды Smalltalk VM или JVM

===== #Адрес подпрограммы#
** Единственная инструкция — вызов подпрограммы,
подразумеваемая по умолчанию
** С другой стороны, расширяемый набор инструкций,
представленных адресами их реализаций
** Пример: шитый код Forth-машины

Bell, J.K., Threaded code, Communications of the ACM
vol 16, nr 6 (Jun) 1973, pp.370-372

Чтобы взять адрес подпрограммы -- нужно взять специальную инструкцию и передать ей в качестве аргумента другую функцию

==== Передача параметров инструкциям.

 todo

=== 1.3. Виды линейных кодов.
==== Байтовый код
Код представляется токенами размера 1 байт (??)

*Пример байтового кода*
 
image::media/bytecode.png[]

 0 - адрес переменной а, 1 - b 

Ниже его интерпретатор на С. В цикле считаем следующий байт, в зависимости от его значения -- выбираем номер следующей инструкции. Логика функции в теле case.

*Интерпретатор байтового кода на С*

```C 
void Interpreter (void) {
    const byte* ip;
    ...
    for (;;) {
        switch (*ip++) {
        ...
        case iadd: {
            const int a = pop();
            const int b = pop();
            push(a+b);
            break;
        }
    ...
        }
    }
}
```
*Интерпретатор байтового кода на assembler*

На asm можно явно выразить некоторые вещи. Например, задать #явный# или #неявный# цикл

*Интерпретатор байтового кода с #явным# циклом*

```asm
InterpreterLoop:
    ; мб 1 инструкция
    tmp = *ip++;
    jmp BytecodeTable[BytesInWord * tmp];
    ...
L_iadd:
    pop tmp1;
    pop tmp2;
    tmp1 += tmp2;
    push tmp1;
    ; ЯВНО переходим на начало цикла
    ; как и все другие инстуркции
    jmp InterpreterLoop;
    ...
BytecodeTable: .word ..., L_iadd, ...
```

Здесь `ip`, `tmp`, `tmp1`, `tmp2` — машинные регистры,
причем tmp может совпадать с `tmp1` или `tmp2`.

`BytecodeTable` -- по токену инструкции хранит адрес ее начала.

`BytesInWord * tmp` -- в машинном слове 2 байта, приводим типы (зачем??)

*Интерпретатор байтового кода с неявным циклом*

Заводим макрос next, который делает то же самое, что декодер процессора (??): выбирает очередной байт из потока инструкций и отдает управление на таблицу интерпретатора.

```asm
next:   macro()
        tmp = *ip++;
        jmp BytecodeTable[BytesInWord * tmp];
        endm

Interpreter:
        next();
...
L_iadd:
        pop tmp1;
        pop tmp2;
        tmp1 += tmp2;
        push tmp1;
        ; здесь подставится код макроса!!!
        next();
...
BytecodeTable: .word ..., L_iadd, ...
```

*Какой интерпретатор эффективнее?*

В случае с явным циклом у нас есть безусловный переход на `InterpreterLoop`, где происходит косвенный переход по какой-то табличке.

К неявного цикла нет безусловного перехода в конце, на этом могут сэкономиться такты процессора (но не обязательно ??). 

Также с точки зрения *предсказателя переходов*, при неявном цикле для каждой инструкции свое место, где происходит переход по табличке. Предсказатель хранит ассоциацию между местом перехода и тем, куда программа дальше пошла. В случае с явным циклом переходы будут практически не предсказуемы. 

С неявным циклом можно предугадывать идиоматические последовательности, когда за одной инструкцией чаще всего идет другая конкретная.

==== Шитый код
Код -- последовательность адресов подпрограмм

Выделяют три вида шитого кода 

● Подпрограммный
● Прямой
● Косвенный

===== #Подпрограммный# шитый код (threaded code)
image::media/threaded_code.png[]

`jsr` — машинная инструкция вызова подпрограммы

`ret` — машинная инструкция возврата из подпрограммы


● Прямой
● Косвенный

==== Токен-шитый код
Гибрид байтового и шитого кода

● Прямой
● Косвенный


=== 1.4. Непосредственные операнды. Кодирование. Литеральный пул.
=== 1.5. Записи активации. Секции стека вызовов.
=== 1.6. Организация стека вызовов
=== 1.7. Нативный интерфейс виртуальной машины. Доступ к данным.
=== 1.8. Кэширование вершины стека операндов.
=== 1.9. Оптимизации при преобразовании распространяемого кода в исполняемый. Специализация инструкций по непосредственным операндам. Замена идиом на супер-инструкции.
=== 1.10. Оптимизации при преобразовании распространяемого кода в исполняемый. Макроподстановка вызовов простых функций.
=== 1.11. Оптимизации кода интерпретатором. Quickening. Специализация инструкций по инвариантам состояния.
=== 1.12. Макроподстановка вызовов простых функций в интерпретаторе.
=== 1.13. Сокрытие переписывания кода интерпретатором.
== Компиляция
=== 2.1. Компиляция статическая, динамическая и комбинированная.
=== 2.2. Варианты динамической компиляции. Динамическая адаптивная компиляция.
=== 2.3. Синхронная, асинхронная и параллельная динамическая компиляция. Консистентность порожденного кода.
=== 2.4. Планирование асинхронных компиляций.
=== 2.5. Динамическое профилирование и предсказание активности интерпретируемого и скомпилированного кода.
=== 2.6. Организация переходов между интерпретируемым и скомпилированным вариантами кода с сохранением состояния (On-Stack Replacement)
=== 2.7. Выбор оптимизаций для динамического компилятора.
=== 2.8. Девиртуализация вызовов.
=== 2.9. Защищенные и незащищенные спекулятивные преобразования.
=== 2.10. Спекулятивная девиртуализация вызовов.
=== 2.11. Локализация объектов.
=== 2.12. Макроподстановка объектов.
=== 2.13. Способы быстрого эвристического  распределения регистров.
=== 2.14. Распределение регистров методом линейного сканирования.
=== 2.15. Однопроходная компиляция путем абстрактной интерпретации. Ветвление и слияние потоков управления.
=== 2.16. Оптимизации однопроходного динамического компилятора.
