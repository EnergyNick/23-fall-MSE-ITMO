:toc:
:lang: ru-RU
:source-highlighter: rouge
:stem: asciimath

= Ответы к экзамену по с/к "Виртуальные машины", 2023-2024

image::media/2024-01-15-16-19-41.png[]

== Интерпретация
=== 1.1. Интерпретация. Виды интерпретаторов. Компоненты итеративного интерпретатора.

==== Интерпретация
#Интерпретация# – это механизм непосредственного исполнения отдельных
языковых элементов (строк, лексем, команд) программ

Исходный текст высокоуровневых программ на ВМ компилируется (мб неявной динамической) в промежуточное представление (#ПП#)

#Форматы кода#
* Распространяемый формат 
** Стандартизован
** Машинно-независим
** Расширяем
** Компактен
** Пример: `.jar` файлы `Java` (архивы с бинарными class файлами)
** Может содержать медиа ресурсы
* Выполняемый формат -- представление кода в памяти VM
** Порождается из распространяемого формата после его конверсии: загрузки, линковки и верификации
** Может дополнять или замещать распространяемый 
** Преобразования мб статически (отдельная стадия) или динамически (в рантайм)
** Преобразование производится не обязательно локально

==== Виды интерпретаторов
[cols="1,2,2"]
|===
|Интерпретатор
|Рекурсивный
|Итеративный


|Выполнение
|Обходит код, рекурсивно вызывая себя
|Перебирает инструкции последовательно в цикле

|Вызов подпрограммы
|вызывает себя c подпрограммой и параметрами её вызова
| формирует новую секцию в стеке вызовов, меняет указатель текущей инструкции, продолжает выполнение цикла

|Параметры и результаты передаются…
|… непосредственно при вызове 
|… в виртуальных регистрах или на стеке операндов

|Применяется для ПП в виде…
|…текста, деревьев или графа
|…потока, последовательности или массива инструкций (линейных кодов)
|===

==== Компоненты итеративного интерпретатора

* Набор инструкций
** add, load, branch... (может быть расширяемым)
* Виртуальные регистры
** ip — адрес текущей инструкции
** sp — указатель стека
** fp — адрес текущей рамки стека вызовов
* Стеки
** Стек вызовов для организации вызовов
подпрограмм, обычно состоит из
рамок/секций/записей активации
** Стек операндов для передачи параметров и выдачи
результатов виртуальных инструкций (может быть
частью стека вызовов или вообще отсутствовать)
* Цикл интерпретатора
** декодер инструкций и их реализация

=== 1.2. Представление виртуальных инструкций. Передача параметров инструкциям.
==== Представление виртуальных инструкций. 
===== #Токен# 
** Целое число, однозначно идентифицирующее
инструкцию и, возможно, все или некоторые из ее
операндов
** Остальные операнды могут быть закодированы в
потоке инструкций вслед за токеном
** Токены не зависимы от аппаратуры и размещения
кода в памяти
** Пример: байтовые коды Smalltalk VM или JVM

===== #Адрес подпрограммы#
** Единственная инструкция — вызов подпрограммы,
подразумеваемая по умолчанию
** С другой стороны, расширяемый набор инструкций,
представленных адресами их реализаций
** Пример: шитый код Forth-машины

Bell, J.K., Threaded code, Communications of the ACM
vol 16, nr 6 (Jun) 1973, pp.370-372

Чтобы взять адрес подпрограммы -- нужно взять специальную инструкцию и передать ей в качестве аргумента другую функцию

==== Передача параметров инструкциям.

 todo

=== 1.3. Виды линейных кодов.
==== Байтовый код
Код представляется токенами размера 1 байт (??)

*Пример байтового кода*
 
image::media/bytecode.png[]

 0 - адрес переменной а, 1 - b 

Ниже его интерпретатор на С. В цикле считаем следующий байт, в зависимости от его значения -- выбираем номер следующей инструкции. Логика функции в теле case.

*Интерпретатор байтового кода на С*

```C 
void Interpreter (void) {
    const byte* ip;
    ...
    for (;;) {
        switch (*ip++) {
        ...
        case iadd: {
            const int a = pop();
            const int b = pop();
            push(a+b);
            break;
        }
    ...
        }
    }
}
```
*Интерпретатор байтового кода на assembler*

На asm можно явно выразить некоторые вещи. Например, задать #явный# или #неявный# цикл

*Интерпретатор байтового кода с #явным# циклом*

```asm
InterpreterLoop:
    ; мб 1 инструкция
    tmp = *ip++;
    jmp BytecodeTable[BytesInWord * tmp];
    ...
L_iadd:
    pop tmp1;
    pop tmp2;
    tmp1 += tmp2;
    push tmp1;
    ; ЯВНО переходим на начало цикла
    ; как и все другие инстуркции
    jmp InterpreterLoop;
    ...
BytecodeTable: .word ..., L_iadd, ...
```

Здесь `ip`, `tmp`, `tmp1`, `tmp2` — машинные регистры,
причем tmp может совпадать с `tmp1` или `tmp2`.

`BytecodeTable` -- по токену инструкции хранит адрес ее начала.

`BytesInWord * tmp` -- в машинном слове 2 байта, приводим типы (зачем??)

*Интерпретатор байтового кода с неявным циклом*

Заводим макрос next, который делает то же самое, что декодер процессора (??): выбирает очередной байт из потока инструкций и отдает управление на таблицу интерпретатора.

```asm
next:   macro()
        tmp = *ip++;
        jmp BytecodeTable[BytesInWord * tmp];
        endm

Interpreter:
        next();
...
L_iadd:
        pop tmp1;
        pop tmp2;
        tmp1 += tmp2;
        push tmp1;
        ; здесь подставится код макроса!!!
        next();
...
BytecodeTable: .word ..., L_iadd, ...
```

*Какой интерпретатор эффективнее?*

В случае с явным циклом у нас есть безусловный переход на `InterpreterLoop`, где происходит косвенный переход по какой-то табличке.

К неявного цикла нет безусловного перехода в конце, на этом могут сэкономиться такты процессора (но не обязательно ??). 

Также с точки зрения *предсказателя переходов*, при неявном цикле для каждой инструкции свое место, где происходит переход по табличке. Предсказатель хранит ассоциацию между местом перехода и тем, куда программа дальше пошла. В случае с явным циклом переходы будут практически не предсказуемы. 

С неявным циклом можно предугадывать идиоматические последовательности, когда за одной инструкцией чаще всего идет другая конкретная.

==== Шитый код
Код -- последовательность адресов подпрограмм

Происходит постоянный переход от кода программы к реализации инструкций. Если представить это линией, то они словно сшиты. Поэтому код #шитый#.

Выделяют три вида шитого кода 

* Подпрограммный
* Прямой
* Косвенный

Может быть несколько реализаций интерпретатора,главное чтобы каждому enter соответствовал exit того же интерпретатора (как ПСП).

===== #Подпрограммный# шитый код
image::media/threaded_code.png[]

`jsr` — машинная инструкция вызова подпрограммы, от процессора `pdp`. У  `intel` -- `call`.

`ret` — машинная инструкция возврата из подпрограммы

iload, iret -- метки реализаций подпрограмм  

*интерпретатор* 

Цикл интерпретатора отсутствует.

```asm
.code
...
iadd:   pop(tmp1);
        pop(tmp2);
        tmp1 += tmp2;
        push(tmp1);
        ;вернуться в исполнение кода 
        ; на следующий jsr 
        ret
```

`iadd` — метка в коде

`tmp1`, `tmp2` — регистры процессора

`pop`, `push` — макросы операций со стеком операндов. Одноименные инструкции использовать нельзя, так как аппаратный стек работает с адресами возвратов, а `pop`, `push` с передачей операндов. Поэтому реализуем макросы!!

Скорость: не так медленно, так как процессор умеет предсказывать ret. И это в любом случае быстрее, чем в ручную искать адрес след операции через табличку. 

`+` Быстрее байтового 

`+` Количество инструкций не ограничено (в отличии от байтового)

`-` эффективен, когда адрес подпрограммы не очень длинный (иначе дорого хранить) и абсолютный (иначе приходится выполнять арифметические операции)

Где используется: postscript (pdf), forth

===== #Прямой# шитый код 
Получается из подпрограммного: у каждого адреса подпрограммы был префикс (за исключением exit). Отказываемся от и избыточного `jsr`.

image::media/right_thread.png[]

`iload`, `iadd` -- адреса, метки на начало реализации

Первая инструкция -- `jsr`, где происходит вход в интерпретатор (`enter`), затем перечень операций после которых -- выход из интерпретатора (инструкция `exit`)

enter / exit — вход в / выход из интерпретатора *данного фрагмента кода*. Адреса метод в коде интерпретатора.

Интерпретатор состоит из трех меток: `enter`, `next`, `exit` и уложен в 7 машинных инструкций!!

*Интерпретатор #прямого# шитого кода*

```asm
next:   macro()
        ; чтение слова -- адреса инструкции
        tmp = *ip++;
        jmp tmp;
        endm
        
enter:  rpush(ip);
        pop ip;
        next();

        ;cнимаем старый адрес интерпретации
exit:   rpop(ip);
        next();

iadd:   pop tmp1;
        pop tmp2;
        tmp1 += tmp2;
        push tmp1;
        next();
```

pop, push — машинные инструкции

rpop, rpush — макросы операций со стеком возвратов

++ — инкремент на размер слова

jsr реализуем вручную: в enter кладем на стек возвратов текущий адрес интерпретации (ip), снимаем с аппаратного стека текущий адрес интерпретации (там лежит адрес iload 0), который выполняется в next. 

Выполнение в next -- читаем адрес следующей инструкции *ip++ и выполняем ее.

===== #Косвенный# шитый код 
Единственный вид шитого кода, который не содержит машинных инструкций (в прямом jsr)! 

image::media/indirect_threaded_code.png[]

Dewar, R.B.K., Indirect threaded code.
Communications of the ACM, June 1975, pp.330-331


*Косвенный шитый код Интерпретатор*

```asm
next:   macro()
        tmp = [ip++];
        jmp [tmp];
        endm

enter:  rpush(ip);
        ; в tmp храним адрес текущего enter из кода!!!
        ; двигаем его на машинное слово и получаем адрес 
        ; следующей инструкции (iload)
        ip = ++tmp;
        next();

exit:   rpop(ip);
        next();

iadd:   .word @iadd
; фиктивная метка реализации
@iadd:  pop tmp1;
        pop tmp2;
        tmp1 += tmp2;
        push tmp1;
        next();
```

Используется дополнительный регистр tmp с побочным эффектом (сперва там лежит адрес текущего enter)

В начале каждой инструкции должен лежать адрес следующей за ней реализации инструкции

`-` интерпретатор сложнее -- дополнительная косвенность, загружаем адрес из памяти, вводим фиктивные метки -- работает медленнее прямого кода
  
`+` нет никаких машинных инструкций, абсолютно независимый от платформы. Можно делать фиксы чтобы поправить адреса

==== Токен-шитый код
Гибрид байтового и шитого кода

● Прямой
● Косвенный


=== 1.4. Непосредственные операнды. Кодирование. Литеральный пул.
=== 1.5. Записи активации. Секции стека вызовов.
=== 1.6. Организация стека вызовов
=== 1.7. Нативный интерфейс виртуальной машины. Доступ к данным.
=== 1.8. Кэширование вершины стека операндов.
=== 1.9. Оптимизации при преобразовании распространяемого кода в исполняемый. Специализация инструкций по непосредственным операндам. Замена идиом на супер-инструкции.
=== 1.10. Оптимизации при преобразовании распространяемого кода в исполняемый. Макроподстановка вызовов простых функций.
=== 1.11. Оптимизации кода интерпретатором. Quickening. Специализация инструкций по инвариантам состояния.
=== 1.12. Макроподстановка вызовов простых функций в интерпретаторе.
=== 1.13. Сокрытие переписывания кода интерпретатором.
== Компиляция
=== 2.1. Компиляция статическая, динамическая и комбинированная.
=== 2.2. Варианты динамической компиляции. Динамическая адаптивная компиляция.
=== 2.3. Синхронная, асинхронная и параллельная динамическая компиляция. Консистентность порожденного кода.
=== 2.4. Планирование асинхронных компиляций.
=== 2.5. Динамическое профилирование и предсказание активности интерпретируемого и скомпилированного кода.
=== 2.6. Организация переходов между интерпретируемым и скомпилированным вариантами кода с сохранением состояния (On-Stack Replacement)
=== 2.7. Выбор оптимизаций для динамического компилятора.
=== 2.8. Девиртуализация вызовов.
=== 2.9. Защищенные и незащищенные спекулятивные преобразования.
=== 2.10. Спекулятивная девиртуализация вызовов.
=== 2.11. Локализация объектов.
=== 2.12. Макроподстановка объектов.
=== 2.13. Способы быстрого эвристического  распределения регистров.
=== 2.14. Распределение регистров методом линейного сканирования.
=== 2.15. Однопроходная компиляция путем абстрактной интерпретации. Ветвление и слияние потоков управления.
=== 2.16. Оптимизации однопроходного динамического компилятора.
