= Interior mutability. Dynamically sized types. Unsized coercion. Any.

== 1. Interior mutability

borrow-chwckong -- запрещает больше 1 mutable ссылки на объект. Но иногда хочется что-то менять за константной ссылкой, например:

* Логическая константность: кешировать результаты вызовов функций с немутабельной семантикой
* Разделяемое изменяемое состояние: нужно иметь ссылки на один и тот же мутабельный объект в разных областях программы 

Паттерн, позволяющий это делать, называется Interior Mutability.

== Cell <T>
Позволяет иметь shared объект, который можно изменять из разных мест. Данные лежащие за константной ссылкой смогут меняться.

Это по сути настоящие данные, а не ссылка. Магическая реализация внутри rust. 

Можно парамтеризировать 

1. тип с trait copy, API: есть API set(..), get(). set константный! cell мб не mut объектом.
2. Для типов, которые реализуют trait default: take(). Он вынимает значение из cell и заменяет его на дефолтное значение.
3. Все остальные: replace -- вернет что было, положит что передали. 

Таким образом мы гаранируем, что cell не разрушается. 

Стоимость

* Не добавляет никаких проверок в runtime 
* Cell<T> обладает ровно таким же layout в памяти, как T.

Это делает возможным метод

```
impl<T> Cell<[T]> {
    //буквально конвертирует сел со слайсом в слайс селов
pub fn as_slice_of_cells (&self) -> &[Cell<T>];
}
```
=> Cell - zero cost abstraction.

НИКОГДА НЕ ВОЗВРАЩАЕТ ССЫЛКУ НА Т!!!!!! (&T)

Потому, что на Cell<T> можно позвать .set() или .replace() и получить
нарушение правил алиасинга(???) и даже use after free.

== RefCell
Полезен, когда нужна ссылка на данные 

Хранит тип Т и счетчик ссылок. Нельзя звать borrow_mut, пока они кем-то держаться.

RefCell осуществляет проверку borrowing rules в рантайме.
При нарушении методы borrow и borrow_mut паникуют.
Есть непаникующие методы - try_borrow и try_borrow_mut.


Ref::map

Можно спустить borrow на подполя структуры:
let refcell = RefCell::new(Person { name: "Bill".to_string() });
let ref_name = refcell.borrow().map(|p| &p.name);


get_mut можно вызвать только 1 раз (по сигнатуре)

impl<T> RefCell<T> {
fn borrow_mut(&self) -> RefMut<'_, T>;
fn get_mut(&mut self) -> &mut T;
}
Первый метод принимает &self и должен валидировать корректность в
рантайме.
Второй метод принимает &mut self, следовательно, ничего валидировать
не должен.

Что использовать? 

У Cell и RefCell разные стоимости:
*  В случае Cell вы платите за перекладывания памяти
*  В случае RefCell вы платите за дополнительную проверку
Rule of thumb:

* Для copy-типов используйте Cell
* Для остальных типов - RefCell

Rc -> &T, &mut T не умеет (по крайней мере если счетчик больше 1).

Поэтому делают так Rc<RefCell<T>> (только в однопоточном сценарии)

Почти эквивалентно Arc<Mutex<T>>

== 2. Dynamically sized types
Размеры объектов известны только во время исполнения! 

* Слайсы: [T], str
* Trait objects: dyn Trait -- два указателя: на данные и vtable                 

Подразумевается, что параметр дженерика -- тип известного размера. Чтобы было не так указываем <T: ?Sized>

При этом если в реализации функции попытаемся положить значение типа Т на стек, то функция не скомпилируется (т.к. мы не сможем выеделить стек нужного размера)

== 3. Unsized coercion

Приводит тип у которого размер известен к тому, у которго неизвестен

Usized coercion (безразмерное приведение) - это приведение типа со
статически известным размером к типу с динамическим размером.

Примеры unsized coercion
```rust
let xs: [i32; 4] = [1, 2, 3, 4];
let s: &[i32] = &xs;
// Пусть Foo: MyTrait.
let foo = Foo { /* ... */ };
let my_trait = &foo as &dyn MyTrait;
let b = Box::new(Foo { /* ... */ }) as Box<dyn MyTrait>;
let rc = Rc::new(Foo { /* ... */ }) as Rc<dyn MyTrait>;
```

== 4. Any 
могут реализоввывать только типы, у которых внутри нет никаких ссылок кроме статических

имеет только type_id, поэтому можно сравнивать типы 