= Open multi processing 

Первый стандарт, который повысил уровень абстракции от чистого многопоточного программирования (от создания потоков напрямую). Intel разработали достаточно общий стандарт. 

Технологически является большим шагом в индустрии, хотя концептуально ничего нового не вносит. 

Создан как расширение для `c++` и `fortran`. Добавляет в эти языки специальные директивы компилятора, библиотечные функции и переменные окружения. 

Иначально предполагался как стандарт, который позволит специалистам в предметной области оптимизировать параллельность программы. Даже если они не профессиональные разработчики.

image::13_omp/2024-01-24-19-08-21.png[]

== Имплементация в С++
Реализовано через директивы компилятора pragma (другие директивы предпроцессора: include, ifndef).

image::13_omp/prepr.png[]

<<pragma-pack, Отступление про pragma pack>>

=== Реализация

Omp зарезервировала pragma-команду omp: `#pragma omp <args>`. 

image::13_omp/example.png[] 

Это директива компилятора сгенерирует код. Код в скобках -- будет вынесен в отдельную функцию и распараллелен. Где скобка закрывается -- будет выполнен join. До вызова функции будет запущен код, который запускает потоки (обычно столько, сколько ядер в системе) и т.д.

Потоки могут узнать, какой они номер из n, используя библиотечные вызовы. Это можно учитывать в логике функций.

Тоже работают. Стандарт не вносит ничего нового, кроме генерации кода.

=== Ключевые слова внутри блока omp parallel

==== master

Код гарантированно будет исполнятся только в одном потоке, у остальных даже не будет этого кода. 

image::13_omp/master.png[]


==== critical

как mutex, т.е. выполнение блока critial синхронизировано.

Есть те же примитивы, но сихронизованные вызовом функций:

image::13_omp/sync.png[]


==== for

подсказывает компилятору, что хотим распаралеллить цикл `for`.

image::13_omp/omp_for.png[]
====
Пример потокобезопасный, т.к. `printf` потокобезопасный. Например, `cout` нет!
====

Индекс цикла копируется в каждый поток (каждому выделяется какой-то свой интервал индексов). Так копируются все переменные в секции инициализации for'а. 

Причем распараллелить for можно только с самым простым определением: перебирание числа от одного значения до другого. Если выражение изменения счетчика сложное -- ничего не получится. Логично, что break также нарушит логику выполнения, ведь другой поток мог успеть обработать числа впереди итерации с выполненным break. 

==== Области видимости переменных


*private* -- значит, что у каждого потока будет своя копия переменной. 

image::13_omp/private.png[]

*shared* (область видимости по умолчанию) -- все потоки имеют доступ к одной переменной. Нужно заботится о потокобезопасности самостоятельно.

image::13_omp/shared.png[]

*reduction* 

image::13_omp/reduction.png[] 

s -- внешняя переменная. Сначала распараллелится цикл и у каждого цикла будет своя приватная s. В каждом потоке будет считаться локальная сумма. 

Потом сгенерируется код, где методом редукции будет собрана конечная сумма во внешней s.

== Проблема одного ядра 

image::13_omp/sections.png[] 

Нужно учитывать, что omp по-умолчанию создает столько же потоков, сколько ядер на системе. Пусть будет один producer и один consumer (на картинке пример посередине). Если будет создан один поток, то мы не переключимся на другую секцию, пока не закончим выполнение текущей секции полностью. Поэтому producer, запущенный первым, никогда не закончится.

Как исправить? Явно попросить исполнять в двух потоках.

== Актуальность 

В последнее время omp развивается в основном в сторону миграции вычислений.

Есть куча устройств, на которых можно выполнять разные вычисления. Процессоры общего назначения, графические карты, платы расширения (PSI) с десятками процессоров общего назначения + куча штук для специализированных вычислений. Писать под каждое устройство код тяжело, т.к. нужно использовать различные api. 

Миграция вычислений (offload) позволяет переносить вычисления omp на другие устройства.

image::13_omp/offload.png[]

Сгенерирует специализированный код, если устройства поддерживает специальные возможности для вычислений.

Также сделали миграцию для nvidia. Без единой строчки на cuda:

image::13_omp/nvidia.png[]

Миграция вычислений:
[.pluses]
* Полезна, интересна
* Кода гораздо меньше, чем на чистой cuda
* Имеет смысл в наукоемких областях. Особенно у не профессиональных разработчиков

[.minuses]
* Пока экспериментальна
* Пока облачные вычисления привлекательнее
* Многопоточные алгоритмы (очереди задач и т.д.) придется писать вручную

== Extra

[#pragma-pack]
=== pragma pack 
Размер структуры {char, int} будет равен сумме размеров полей, дополненной до ближайшего справа целого, кратного машинному слову. Иногда нам хочется строго расположить эти поля в памяти, например, в сетевых протоколах четко расписаны все биты и байты. Директива pack отключает выравнивание, убирая пустое пространство между полями, поэтому можно накладывать эти структуры на битовый поток.

Предметная область: сетевое программирование, сети с ограниченной пропускной способностью. Но protobuf такие проблемы тоже умеет решать.
