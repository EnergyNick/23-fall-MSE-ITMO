= Многопоточность или IPC

IPС - Inter Process Communications (межпроцессное взаимодействие) -- обмен данными между потоками одного и/или разных процессов.

== Виды IPC
* `pipe` (специфичный для ОС механизм -- виртуальный файл, очередь где мы в режиме `FIFO` можем общаться между процессами (обычно двумя). Могут быть именованными или нет (тогда используем дескриптор)).
* `shmem` -- shared mem -- предполагает, что между двумя и более процессами выделяется участок общей ОП (между всеми потоками разных процессов).
* `socket` -- общение по сети или в рамках одной машины (unix-socket). От pipe отличается тем, что в общем случае работаем именно в терминах сетевого взаимодействия: общаемся через дескрипторы сетевых портов, имеем меньше технических ограничений
* `file` --  синхронизирован на уровне ОС. Может быть открыт многими пользователями.
* `signal` -- отличаются от всех остальных 
** По природе асинхронный. Подписываемся на `callback`.
** Не можем передавать данные при этом способе взаимодействия. Только сообщить, что что-то произошло.


`fork` --  вызывается внутри потока, но копирует весь процесс.

`ulimit -a` -- лимиты пользователя, которые установлены для данной консоли, например (в рамках процесса)


== Критерии выбора способа реализации

Коротко: многопоточка проще и быстрее (TLB). IPC безопаснее и надежнее. 

Подробнее ниже

[cols="1,1,1"]
|===

|Критерий
|Потоки
|Процессы (общаются через `IPC`)


| скорость создания (обычно не популярный критерий, зависит от архитектуры)
| *+ быстрее*
| копировать процесс медленнее


|обмен данными
|*+ проще*, меньше строк кода => меньше ошибок
|pipe, дороже


|скорость обмена данными
|*+ быстрее* при интенсивном обмене данными (выше попадание в кеш `TLB`) 
|при переключении разные адресные пространства и кеш гарантированно инвалидируется (мб не физически)


|надежность: если в одной части программы что-то идет не так, как это влияет на другие
|если в одном потоке ошибка -- убиваются все потоки процесса
|*+* при падении процесса все остальные *продолжают работать*


|безопасность
|
|*+* отдельный пользователь (вкладка браузера) -- отдельный процесс. вредоносный код одной вкладки *не влияет на другую*.
|=== 


*TLB* -- таблица, которая отображает виртуальный адрес в физический. Скорость доступа к ее кешу быстрее, чем к ней. 

Единица планирования ОС -- это поток. Он ест процессорное время. Процесс -- больше организационная сущность. Когда потоки переключаются в рамках одного процесса -- они продолжают использовать одно и то же адресное пространство.


== Надежность 

Надежно ли ядро нашей ОС?

Монолитное ядро -- то, что работает в одном процессе. Который иногда подгружает библиотеки и модули. Значит ядра ненадежные и если оно упадет, то будет `kernel panic`. Такое написать намного проще.

Но вообще можно попросить ядро, в случае kernel panic -- оно запускать себя же на зарезервированной памяти и делать dump ядра, которое упало в специальную область памяти.

=== Когда нужно делать многопроцессорную архитектуру на одной машине?
Система ответственного применения: мы не можем точно знать, что наша система не имеет ошибок и подстраховываемся. Актуально для атомных электростанций, космических кораблей, авионика (авиационная электроника). Но очень дорого!

В авионике используют *микропроцессорную архитектуру*: набор модулей broker -- самый главный  и отлаженный. Обеспечивает взаимодействие между модулями.

image::02/broker.png[]

== Безопасность (shmem)
Вредоносный код, который исполняется, не может произвольно перейти из одного процесса в другой. IPC защищает от этого, если в shmem не хранятся чувствительные данные.

Как сделать ее быстрой? Можно использовать shmem. Но это разные расширения адресных пространств (10 + х и 100 + хб например). Поэтому в shmem нельзя хранить сырые указатели, нужно использовать специальные обертки над указателями.

Примитивы синхронизации: если процесс захватил примитив и умер, то ресурс никто нормально не освободит.

image::02/shmem.png[]

== Как завершать потоки (POSIX)
create (fun)


[cols="1,1"]
|===

|I
|II

|

```
create(fun)

pthread_cancel(f)
//вводит флаг в контексте потока II
//но никаких гарантий это не дает
join
```

|

```
//тут освобождаем всякое
...
pthread_cleanuppush(g)
pthread_testcancelled()
--проверят, выставлен ли флаг отмены 

--если да -- в ней выполнится выход из потока и размотка стека cleanup


_unlock(m)
_cleanuppop()



```
|===

g(){
    unlock_sync_primitives
}

testcancelled знает про стек указателей на функции, которые должны освобождать примитивы. Мы их кладем и извлекаем по необходимости.

Как прервать ожидаемый поток, если пользователь решил отменить? 

Жестко лучше не отменять (stop), т.к. могут остаться захваченные мониторы/ неконсистентное состояние.

=== Принудительное завершение exception/cancelletion point(?)

В функциях sleep, read и т.д. могут проводится проверки флага и выход из метода если он истинен.

Можно разрешать не завершаться! 

_disable_cancelled

Нужно, когда важно логически объединять команды.

== glibc
флаг: 

image::02/flag.png[]

поля структуры базовой для потоков 


Когда завершаем поток `do_cancel` все равно вызывается (?)

== На человеческих ЯП 

```Java

class some {
    public void foo(){
        while(!t.isInterrupted())
        try{
            sleep(10);
        }
        catch(InterruptedException){

        }
    }
}
```
есть еще метод `::interrupted()` -- он возвращает флаг и сбрасывает его. IsInterrupted просто возвращает значение.



[cols="1,1, 1, 1"]
|===

|cmd 
|posix 
|c++11
|java

|Cancel (please)
|cancel
|none
|interrupt

|===


=== Задачка 
Хотим 2 элемента из  очереди, но метод, делающий этот постоянно interrupt какой-то поток-диверсант. Можно вынести это в отдельный поток.


== boost 

имеет похожую логику. но у них свой флаг. значит они не смотрят на флаг посикса. и че там происходит нехорошее и в стандарт это не внесли

== cas  
compare and set -- атомарная операция сравнения и сета. реализована на уровне процессора. но в user space. блокирует шину.

Четные примитивы синхронизации -- попадаем в kernel space. при нечестных -- нет.
Зачем при переходе переходим в kernel space.

== kernel space 
адресное пространство процесса ядра. там куча данных. структуры данных, алокатор памяти, планировщик, примитивы синхронизации. 

== user space 
прикладной код. при выполнении функций-системных вызовов (new, другое выделение памяти) это все через цепочку вызовов и использует интерфейс ОС из syscall системные вызовы -- реализация функций, описанных в стандарте POSIX. 

Код системной функции -- просто функция, но реализованная в ядре ОС. Просто вызвать его нельзя, т.к. он используетт методы ядра ОС, а обращаться к пространству другого процессора нельзя.

При выполнении syscall меняется контекст (регистры) и продолжается выполнение *того же* потока, но уже в kernel space. То есть код ОС выоплняет наш же поток. Это защищенное пространство, пользовательский код отсюда вызвать нельзя (чтобы нельзя было выполнять вредноносный код). После выполнения кода поток выныривает из kernel space и продолжает исполнение.

Выныривание и заныривание очень дорогая операция! частота процессора 10:9 процессорных инструкций. В секунду можно вызвать максимум миллион функций ОС из-за переключения контекста. Любой вывод -- это обращение к процессору, поэтому это так дорого.пока из всех преподов он и АМ круче всех рассказывают

=== Когда переходим в kernel space при захвате примитивов синхронизации? 

Зачем примитиву синхронизации провариваться в kernel space?  Если поток пришел и мьютех уже захвачен -- он говорит ОС, что он заблокирован и ОС ставит его в очередь заблокированных и не ставит на исполнение, пока ресурс не освободится.

=== Когда не нужно
Может не захватывать, если поток пришел и захватил примитив (установил флаг в мьютексе в своем адресном пространстве с помощью cas). 

А еще можем не вставать в очередь, а попытаться еще несколько раз захватить. Вдруг он освободиться.

cancellation point -- любой метод, где внутри вызывает thread_cancell(ed?). Если мы не будем его вызывать, то никогда не сможем завершить заснувший на год поток.

== Extra 
=== Степени связности объектов 
*Степени связности объектов* ~~ сколько кода нужно изменить, чтобы разорвать связность объектов. Указаны в порядке убывания.

1. Дружественность (`friend`). Самая сильная степень связности, т.к. имеем доступ к private полям.
2. Наследование (не зависим от private полей и методов).
3. Композиция (время жизни родителя такое же, как у ребенка: завязаны на время жизни объекта). 
4. Агрегация (можем создавать объекты в разных местах приложения и связывать их).

Композиция и агрегация -- дети ассоциации

Связи бывают:

* `Неинтрузивные` -- пользуемся только публичным интерфейсом. 
* `Интрузивное` -- проникаем в непубличные внутренности. Интрузивные указатели в `C++` умные указатели, когда передаем извне специфический (например, для ОС) способ подсчета ссылок.

=== О сигналах

`dd if=/dev/zero of=/dev/null` -- копирует генерируемые нули в пустоту.

`dd` -- копирование низкоуровневое

`if` -- input file 

`kill SIGUSR1 <pid>`

`SIGUSR1` -- никакой сигнал. Пользовательский, можем придумать какую-то логику для пользовательских сообщений.

Всего их 2.
 
Если отправить процессу сигнал, на который у него нет обработчика -- он умрет (аналог `SIGTERM` -- `Ctr + C`).
