= 7. Модели памяти: барьеры

== Барьеры памяти

=== Зачем барьеры?  Пример, когда кеши ломаются
Пусть мы хотим исполнить следующий код в двух потока. В табличках -- переменные в кеше процессора и их состояния. 

image::mem_model/1.png[]

Распишем выполнение по шагам 

* 1. [1] Меняем а, отправляем read/invalidate 
* 2. [2] просим у брокера прочитать b, так как его нет в кеше
* 3. [1] Обновили b -- modified
* 4. [1] Получили от запрос на чтение b из шага (2). b  переходит в shared

image::mem_model/2.png[]

* 5. [2] b в кеш

image::mem_model/2024-01-26-17-27-59.png[]

* 6. [2] b==1 -> выходим из цикла 
* 7. [2] assert(a == 1). но мы еще не обновили а в этом кеше, падает с ошибкой 
* 8. [2] Ядро начинает запрос на инвалидацию из шага (1)
* 9. [1] Сброс store buffer


== Теоретические барьеры памяти  
Пусть X, Y принимают значение либо load (чтение), либо store(запись)

Барьер памяти -- ассемблерная инструкция, вида X_Y,  которая гарантирует, что все все операции типа Х до барьера гарантированно выполнятся до всех операций типа Y после барьера 

Все барьеры применяются только на одном ядре! Налаживаем частичный порядок работы (с кешами) в каждом из потоков и таким образом в целом что-то хорошее выходит.

===  Acquire/release семантика
Поэтому выделяют 4 вида барьеров 

image::mem_model/bar.png[]

При этом их дополнительно выделяют в группы. 

image::mem_model/aqq_rel.png[]

Логически acquire захватывает что-то, а release освобождает. Поэтому получается единый логичесикй блок.

image::mem_model/2024-01-26-17-44-36.png[]

Написание acquire эквивалентно тому, чтобы написать 

```
LoadLoad 
LoadStore
```

== Модель памяти
Модель памяти -- набор барьеров, которые автоматически гарантирует конкретная архитектура или иной уровень абстракции (наиболее высокий уровень абстракции).

Модель памяти может гарантироваться: 

* архитектурой процессора
* фреймворком 
* языком программирования высокого уровня (должна гарантировать на всех машинах независимо от модели памяти архитектуры, на котором будет исполняться код)

=== 1. Sequential consistency
Любая операция и чтения и записи приводит к применению всех 4 барьеров памяти. 

Если какой-то процессор предоставляет его, то у него нет ни `Store Buffer` ни `Invalidate Queue`. Он всегда работает честно.


=== 2. Strong order (TSO -- total store ordering), сильная модель памяти
Для любой операции гарантирует `acquire/release` семантики. Т.е. не использует `StoreLoad`. 

Пример: AMD64 (синоним X86_64), X86 (она для 32 битной)

==== Когда нужен storeLoad?

Пример, который не покроет `acquire/release` семантика.

```
x = y = true
```

Поток 1

```kotlin
fun f(){
    x = false
    //сюда storeLoad
    assert(y)
}
```

Поток 2

```kotlin
fun f(){
    y = false
    //сюда storeLoad
    assert(x)
}
```

Чтобы разрешить это -- нужно использовать `StoreLoad`. В AMD как раз так, он допускает reordering в случаях StoreLoad,  т.е. такие случаи нужно указывать явно.

Нормальное поведение -- один из assert упадет.

=== 3. Weak ordered (Слабая модель)
Архитектура/ЯП заставляет явным образом задумываться о всех 4 барьерах памяти. Ни один не поддерживается! Нужны все явно.

Пример: ARM v7. Средняя производительность выше при той же частоте, но больше ошибок.


=== 4. Super-weak 
Есть возможность перестановки инструкций зависимых по данным в одном потоке (можно переставить местами вторую и третью строки).

Пример: Alpha

```cpp 
int * x;
x = new int(20);
*x = 5;
```
== Примеры 
=== jre 
При работе с volatile компилятор в байткод анализирует код и ставит один из барьеров. Затем для каждой архитектуры оно реализуется по-своему.

Реализует слабую модель памяти.

=== Нативные ЯП 
В c++ atomic `load` и `store` модель памяти передается как аргумент (та, которую мы хотим). По умолчанию -- самая сильная модель памяти. Может это и не оптимально, но безошибочно.

Можно без атомиков явно взять и поставить барьер памяти посередине кода.

consume -- StoreLoad -- самый ядерный барьер, и invalidate cash чистит и Store Buffer.

relaxed -- без барьеров памяти. Чистое чтение/запись. Имеет смысл, если на каком-то этапе работы приложения переменная нужна в каком-то более-менее свежем состоянии (счетчик и т.д.) 

*Максимальная производительность*

isReady -- атомик флаг


Первый поток:

```cpp
void f(){
    data = 42;
    //StoreStore -- release
    ready.store(true, ?);
}
```

Второй поток:

```cpp
void g(){
    if(ready.load(?)){
        //LoadLoad -- acquire
        assert(data == 42);
    }
}
```

Это максимально производительный код на CPP.

Почему не дали отдельно барьеры памяти? Не на все архитектуры и языки можно реализовать.

== Неявное применение барьеров памяти

Даже не зная о барьерах памяти, мы применяем их 

* Примитивы синхронизации. Иначе нельзя: у примитива есть флаг, который разделяется между разными потоками.
* смена контекста потока, окончание планирования (как производные -- sys_call, join и т.д.). Ответственность за подчисткой контекста на выжившем потоке.

`atomic` (lock-free алгоритмы и т.д.) применяют их явно.

`volatile` в java -- способ явного указания для использования барьеров памяти. В с++ volatile никакого отношения к барьерам памяти не имеют.