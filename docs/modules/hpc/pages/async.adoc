= Async вводная часть 
Ввод вывод бывает: (не) блокирующий, (не) синхронный 

Будем говорить и о файловом, и о сетевом.

== Блокирующий или нет

=== Блокирующий io 
`read(buf, 1024)`

Когда выйдем из метода? Если данных нет -- заблокируются в этой функции, пока данные не появятся. Ждет, пока прочитают что-нибудь или файл закончится.

=== Неблокирующий io 
Устанавливаем дексриптору (числу, которое сооветсвует ресурсу) ресурса флаг `o_nonblock`. 

Если нет данных -- та же самая функция вернет 0 и выйдет.

write -- не будем ждать, пока переполненный буфер записи освободится.

== Синхронный / асинхронный 
Сигналы -- асинхронные. Не передают данные. не знаем, когда они придут.

Не знает следующую строку: когда будет вызван колбек на операцию.

== Шаблон Proactor 
`observer & callback`

image::09/2023-12-01-19-31-04.png[]

Initiator -- сущность, которая отвечает за инициацию начала асинхронной операции.

Берем и создаем асинхронную операцию: прям честно метод async_read, например.

Чтобы обработать данные, которые ко мне придут -- нужно создать callback -- completion handler --  это функция f(...), которая передается в асинхронную операцию при ее заказе.

AsyncOperation идет в страшную сущность AsyncOperationProcessor -- отвечает за все внутреннее. 

Есть очередь событий EventQueue, которые произошли на тех дескрипторах ресурсах, которые были в заказанных операциях. Обычно это ядро фреймворка асинхронного ввода/вывода.

Что значит произошли? Когда данные пришли магическим способом, он эти данные вместе с соответствующей операцией кладет в очередь данные которые пришли или ошибку, их тип и колбек. 

`EventDemultiplexor` разгребает очередь событий методом poll(). `Worker` по сути.

Proactor -- тот, кто после работы demultiplexora вызывает функцию f(...), которая была задана handler'ом. Обычно это наш код, поэтому он вне фреймворка. Обычно вырожденная сущность, которой может и не быть.

Часто внутри колбека вызывается другая асинхронная функция и proactor становится инициатором. Потому что обычно мы подписываемся только на чтение одной порции данных. Поэтому колбек подписывается повторно. 

=== Почему один колбек лучше?

Обычно нельзя подписаться на множество события по одному дескриптору, а только на единичное событие. Почему?

`UDP` сокет `datagram`. Мы точно отправили за 1 send 1400 байт. Есть ли гарантия, что мы строго за одну операцию чтения получим либо все данные, либо ничего? Да, гарантируется протоколом.

А для `TCP` `stream`? Нет.

Поэтому в демультиплексере пришлось бы учитывать еще и порядок обработки! Так как пришли и обрабатывались одновременно несколько частичек одного и того же сообщения.

Поэтому на сообщения одного и того же сокета, одного типа обрабатывать не получилось бы.


СОКЕТЫ -- это просто обертки над портами. Смотрим tcp сервер


На серверном сокете делает асепт. Когда подключается клиент -- создается конкретный сокет с этим клиентом.

== Реализация Async Processor
=== 1. Функция мультиплексор (селектор)
принимает массив дескрипторов (только тех, что нам интересны!!! и соответсвующих типов событий) и проверяет наличие событий на них. Примеры таких функций:

* `select` O(n), n -- число дескрипторов
* `poll` 
* `epoll` O(1), завязано на ядро линукса
* `kqueue` 
* ...

Обычно одна из этих функций (какая -- зависит от версии ос и тд) выполняется в отдельном потоке.

Эти функции -- `системные вызовы` (как и обычный read), но обрабатывают сразу кучу сокетов за раз.

Здесь заранее говорим, что нас интересуют вот такие типы событий на таком сокете.

Можно оптимизировать чтение через dev/epoll 

Оптимизируют ввод/вывод сокращяя количество системных вызовов.

=== 2.  Интерфейс ОС

Иногда часть ОС предоставляют свой интерфейс для этой задачи. Linux, например, AIO. И логика селекторов спускается на уровень ядра ОС. Правда, данные из ядра ОС нужно получать экзотически (сигналы и их обработку и т.д.)

image::09/2023-12-01-21-08-30.png[]

Reactor -- часть async Op processos, которая не связана с Async

`+` передаем дела фреймворку, снижает количество системных вызовов

---

Многозадачность бывает кооперативная (потоки не говорят чего они хотят, а говорят когда они закончали задачу и добровольно отдаеют управление другой задаче мб в рамках одного потока) и вытесняющая (фиксированные кванты времени выделяются потокам и независио от желаний потока -- он снимается с исполнения и ставится другой). Асинхронное однопоточное -- это кооперативное.
