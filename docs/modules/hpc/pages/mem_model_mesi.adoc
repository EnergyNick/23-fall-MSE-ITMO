= 7. Модель памяти. MESI
 
https://my.compscicenter.ru/attachments/classes/file_DZjzX6Zq/whymb.2010.06.07c_axdJNMQ.pdf[Исходная статья]

== Пример ошибки в ядре ОС

Проблема: система на Linux, случайно раз в среднем раз сутки видео зависает и все (оператор перестает видеть). Зависает на бесконечное время, если ничего не делать. После перезагрузки сервера чинится. Если перезагрузить клиента, то мы вообще ничего не получаем.

Цель: сделать, чтобы система работала.

Способы поиска ошибки: 

* Считать состояние процесса: подглядеть через виртуальную файловую систему (через `progfs`). У каждого потока можно прочитать стек.
* можно было запустить gdb без последующего запуска приложения.
* core dump uliit -c unlimited -- смотреть дамп без ограничений. Можно искусственно убить приложение (kill). 

Так можно обнаружить, что система падает на системном вызове. Это был баг в ядре ОС, неправильно вызвался futex. Пофиксили явным обращением к барьеру памяти. 

image::mem_model_mesi/os_error.png[]

==  Устройство кэшей процессора

Ядра процессора всегда читают данные из своих кешей (несколько kB)

Ядро не читает напрямую из RAM, а отправляет сообщение read аппаратному брокеру. 

image::mem_model_mesi/mem1.png[]

Брокер его обрабатывает и в кеш записывается память из RAM. Причем размер читаемого участка дополняется до размера линейки кеша.

image::mem_model_mesi/mem2.png[]

Если второе ядро запрошивает те же данные, то брокер может не обращаться к RAM второй раз, а скопировать из быстрой памяти первого процессора

image::mem_model_mesi/mem3.png[]

Протокол #поддержки конкурентности кешей# -- набор сообщений и их последовательности для поддержки когерентности.  

#Когерентность# кэша — свойства кэш-памяти, означающее целостность данных, хранящихся в локальных кэшах, разделяемой системы. Каждая ячейка кэша имеет флаги, описывающие, как ее состояние соотносится с состоянием ячейки с таким же адресом в других процессорах системы.


== MESI 
Существует несколько протоколов, мы рассмотрим учебный пример MESI (имеет 4 состояния, в реальных около 20).

Добавляет к каждой линейке кеша два байта состояния. Линейка кеша может быть в одном из 4 состояний.

* Модифицированная (M) -- может быть помечена только линия в одном кэше. Линия была изменена, но до памяти эти изменения еще не дошли. Хозяин такой линии может спокойно читать и писать в нее без опроса остальных.

* Эксклюзивная (E) -- может находиться только в одном кэше. Содержащиеся в ней данные полностью идентичны данным в оперативной памяти. Записывать и читать из нее можно без внешних запросов, так как она хранится только в одном кэше. После записи такая строка должна быть помечена, как модифицированная.

* Разделяемая (S) -- может одновременно содержаться в кэшах нескольких устройств и использоваться совместно. Запросы на запись в такую линию всегда идут на общую шину, что привод к тому, что все линии с таким адресом в остальных кэшах помечаются как недействительные. При этом содержание основной памяти также обновляется. 

* Недействительная (I) англ. invalid. Такая линия считается невалидной и попытка прочитать приведет к кэш-промаху. Линия помечается недействительной в случае если она пуста, содержит устаревшую информацию или запрошена, но еще не прочитана.

image::mem_model_mesi/mesi_state.png[]

=== Модификация 

Пусть есть разделяемая ячейка со значением 2.

image::mem_model_mesi/shared_inc.png[]

Первое ядро меняет с двойки на тройку. Теперь в системе у одних данных 3 значения. После изменения ядро отправляет брокеру запрос  -- `read invalidate`, который инвалидирует старые данные и просит перечитать данные. После этого первое ядро приостанавливает работу, пока не получит подтверждения.

image::mem_model_mesi/mesi1.png[]

Эти подтверждения -- invalidation acknowledgment -- все остальные ядра отправляют брокеру после того, как получили команду read\invalidate, инвалидировали линейку и запросили новые данные у первого процессора. 

image::mem_model_mesi/mesi2.png[]

[.minuses]
* ядро-отправитель ждет подтверждения 
* ядро-получатель должен бросать свои дела и инвалидировать 

Чтобы решить эти проблемы в архитектуру процессора ввели специальные аппаратные элементы.

* *store buffer* -- хранит линейки кеша, после изменения которых другие ядра еще не прислали подтверждение. Поток-отправитель продолжает работать, но на эти линейки кеша наложены ограничения. 
* *invalidate queue* -- очередь на инвалидацию, своя у каждого ядра. Запрос на инвалидацию обрабатывается не сразу, а когда ядро явно начнет обработку. При этом подтверждение отправляется когда запрос добавлен в очередь. 

image::mem_model_mesi/store_buf.png[]

Пусть первое ядро обновило двойку. Оно обравило запрос в брокер, а измененный кеш -- в очередь. 

image::mem_model_mesi/q1.png[]

Брокер передал запрос на инвалидацию дальше ядрам с этой линейкой 

image::mem_model_mesi/q2.png[]

Ядра отправляют подтверждение после того, как добавили его в очередь инвалидации. Хотя фактическb данные пока не синхронизировали.

image::mem_model_mesi/q3.png[]

Первое ядро получает подтверждение, удаляет запись из буфера и продолжает работать с этими данными. 