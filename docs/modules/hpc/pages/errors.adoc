= 6. Ошибки || программирования 



        Гонки данных (Data Race)
    Специфические ошибки
        Реакция потока на сигнал
        Блокировки при fork многопоточных программ
        Проблема ABA
        Инверсия приоритетов


== 1. Общие: Взаимная блокировка -- Deadlock 
Состояние приложения, когда из-за некорректной работы с примитивами синхронизации работа приложения прекращается (приложение в "вечном ожидании").

Способы получить deadlock

=== 1. Нерекурсивные примитивы синхронизации
С нерекурсивными примитивами синхронизации  deadlock можно схватить даже в одном потоке.


a. просто хватаем дважды
    ```
    b.lock()
    b.lock()
    ```

b. отреагировать на сигнал ?

=== 2. Перекрестный 
1: 

a.lock()
b.lock()

2: 

b.lock()
a.lock()

Как чинить? Иерархическая блокировка. Обеспечиваем одинаковый порядков везде, сортируем примитивы 

Тем более мы профессионалы и хорошо инкапсулируем код, поэтому есть частичная организация. Поэтому образуется и общая.

Если между захватами есть логика, то нужно делать это вручную.

Как нельзя исправлять?
1. Выставлять таймауты
2. Добавлять новые примитивы синхронизации, который отождествляет объединение этих двух. Так плохо, лучше бы мапить примитив к данным 1 к 1 

== Специфические 1:  Реакция потока на сигнал
Есть обработка сигналов. Подписываемся на сигнал, вешаем обработчик. В каком потоке она будет поймана и обработана? 

Варианты 

1. main 
2. новый созданный поток, который join'ится 

    (нет. во первых, не царское дело создавать новый поток. во вторых, наша логика может быть завязана на однопоточность)

3. поток, который подписался (sigaction).

     Нет, т.к. этот поток мог перестать существовать конда пришел сигнал.

4. случайный 

    (Правильный ответ. приостанавливаем выполнение кода потока и подсовываем туда код обработчика. при создании потока в C++ можно задать флаг, что он не хочет обрабатывать такие потоки. Если все против, то берём последний, который не успел отказаться. Поэтому лучше не писать сложную логику в обработчике сигналов. Можно делать какой-то флажок.
    
    Пример deadlock: залочили list, вызвались как обработчик и очистили его. Дальше работает с пустым листом и падаем.)

== Специфические: 2. Блокировки при fork многопоточных программ
Есть 1 процесс, в котором два потока. Так получилось, что в этом процессе есть еще примитив синхронизации и структура данных, ассоциированная с ним, чтобы он его защищал.

Второй поток захватил примитив.

Первый поток делает форк процесса. Появился второй процесс p2.

fork -- системный вызов, который создает еще один процесс, которыя является полной копией (адресного пространства, кучи и т.д.)

метод fork вернет в родиетеле id потомка, во втором -- исполнение начнется со строчки fotk, который вернет 0.

mutex копируется в текущем состоянии, т.е. в заблокированном (просто флажок).

Сколько потоков будет в форке? 1, копируется поток, в котором был вызван форк (стандарт ОС). Т.к. это единственный поток, который мы детерминированно и всегда одинаково знаем, откуда его запустить.

Если бы мы решили копировать все, то брали контексты всегда по разному, т.к. мы бы ловили их все время в разном состоянии. Поэтому повторяемости не было бы.

Если теперь форкнутый поток хочет захватить ресурс, то он никогда не дождется его освобождения (т.к. флаг "занят" и никто не может его освободить). Если поток взял ресурс и умер, но не отпустил, то ресрус в неконсистентном состоянии и не должен не достаться никому.

в Posix есть `pthread_and_fork`(* f_ptr1, * f_ptr2,  *f_ptr3) -- регистрация трех callback. Эта функция обеспечивает выполнение первой функции в рамках первого процесса до форка, второй в раках первого процесса после форка и третьего в рамках второго процесса после форка (до форка его еще не было) соответсвенно.

Как решать эту проблему? 

Захватываем на общем основании вообще все ресурсы. Отпускаем их в первом потоке и во втором. Но как второй процесс освободит ресурсы, ведь его поток уже с другим ID?

Fork работает как корова 

второй процесс сначала физически ссылается на память своего предшественника. в таблице страниц виртуальной памяти для 1 и 2 потока указывают на одну память физическую, пока один из процессоров что-то не поменяет.



== Основные 2. Гонка данных (Data race)
Ошибки из-за несогласованного конкурентного доступа к данным.

Примеры

1. Система 32 битная, но есть условные 64 битные структуры. Чтение может произойти, когда записана только первая часть. Считываем значение которого нет.
2. При копировании часть объекта скопировалась от одного объекта, а другая -- от другого того же типа. Этот объект может просто гулять по системе и мы его можем не увидеть. Получаем объект, которого нет.
3. Один байт x = 0. Делаем инкремент в разных потоках. Инкремент сложный, из трех операций `mov inc mov`. Можем получить ошибку: результат, который нельзя получить линейно.

Если тысяча потоков пишет и читает в однобайтовую переменную без синхронизаций, есть ли тут гонка данных? 

 С точки зрения предметной области примера нет. Если хотя бы 1 поток инкрементирует, то уже гонка данных.

=== false positive data trace 

В этом примере valgrind может обознать гонку данных. В одном потоке читение, в другом запись. Синхронизации нет, но valgrind пишет о потенциальной гонке данных.

```cpp
class X {
    const int a;
    public: X(): a = 1{}
    void print(){
        create_thread(){
            std::cout << a;
        }
    };
}


int main(){
    X x;
    x.print();
}

```


== Специфические 3. Инверсия приоритетов

Инверсия приоритетов возникает тогда, когда нить с низким приоритетом захватывает взаимную блокировку, приостанавливая выполнение нити с высоким приоритетом. Такая нить может неограниченное время сохранять взаимную блокировку, так как ее приоритет низкий. Из-за этого не удается обеспечить выполнение нити за заданный срок.

Рассмотрим пример. Система с одним процессором. В многопроцессорных системах инверсия приоритетов возникает в аналогичных ситуациях.

В этом примере взаимная блокировка M защищает некоторый общий ресурс. Приоритет нити A равен 100, поэтому она часто добавляется планировщиком в очередь на выполнение. Приоритет нити B равен 20. Эта нить выполняется в фоновом режиме. Приоритет остальных нитей процесса - около 60.  

Поток A

```cpp
pthread_mutex_lock(&M);             /* 1 */
...
pthread_mutex_unlock(&M);
```

Поток B

```cpp
pthread_mutex_lock(&M);          /* 2 */
...
fprintf(...);                    /* 3 */
...
pthread_mutex_unlock(&M);
```

Рассмотрим следующий порядок выполнения нитей: запускается нить B и выполняется строка 2. При выполнении строки 3 нить B останавливается и запускается нить A. В ней выполняется только первая строка, после чего нить блокируется, так как взаимная блокировка M захвачена нитью B. В результате будут выполняться другие нити процесса. Поскольку нити B назначен очень низкий приоритет, ее выполнение может возобновиться только через длительное время, в течение которого, несмотря на свой высокий приоритет, будет блокирована нить A

=== Пример из жизни

Такой пример был в марсоходе на ОС жесткого реального времени VxWorks. Поток B -- был прикладным, что-то измерял. Поток А -- брокер обмена сообщениями, шина данных. У А и B были общие примитивы (данные нужно считывать). С -- отвечало за связь с землей.

И поток С приводил к перезагрузкам системы. В ОС есть watchdogs, которые срабатывают, если система стагнирует. Процесс стагнировал, связи с землей не было (сигнал шел долго).

Как решать эту проблему? 

Когда приоритетный поток захватывает примитив синхронизации, который захватил менее приоритетный процесс -- мы поднимаем приоритет меньшего выше большего, исполняется и приоритет снижается до начального состояния.

== Extra

=== Диагностика 
debugger, info_threads

gdb - p <proc_id> -- подключиться через отладчик к процессу 

valgrind (c++) имеет архитектуру vm, пропускает все вызовы через себя, смотрит память побайтово (valgrind --tool=helgrind kate) 


ошибка: `lock order violated`

Алгоритм поиска: журналирует захваты. Ограничения такого способа отладки:

1. не может анализировать spinlock и пользовательские mutex.
2. не детектирует на сигналах
3. не все потоки исполнения анализируются: не детектит, если код не исполнялся
4. должен знать, что mutex -- это mutex
5. должен знать, что может быть потенциальный ???