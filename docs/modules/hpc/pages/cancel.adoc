= 2. Завершение потоков  (TODO)



== Корректное завершение потоков
=== cancellation points
=== interrupted exception
=== примеры кода в glibc
== Сравнение различных потоков (POSIX, boost, java)
== Проброс исключений между потоками


== (POSIX)
create (fun)


[cols="1,1"]
|===

|I
|II

|

```
create(fun)

pthread_cancel(f)
//вводит флаг в контексте потока II
//но никаких гарантий это не дает
join
```

|

```
//тут освобождаем всякое
...
pthread_cleanuppush(g)
pthread_testcancelled()
--проверят, выставлен ли флаг отмены 

--если да -- в ней выполнится выход из потока и размотка стека cleanup


_unlock(m)
_cleanuppop()



```
|===

```
g(){
    unlock_sync_primitives
}
```
testcancelled 

знает про стек указателей на функции, которые должны освобождать примитивы. Мы их кладем и извлекаем по необходимости.

Как прервать ожидаемый поток, если пользователь решил отменить? 

Жестко лучше не отменять (stop), т.к. могут остаться захваченные мониторы/ неконсистентное состояние.

=== Принудительное завершение exception/cancelletion point(?)

В функциях sleep, read и т.д. могут проводится проверки флага и выход из метода если он истинен.

Можно разрешать не завершаться! 

_disable_cancelled

Нужно, когда важно логически объединять команды.

== glibc
флаг: 

image::cancel/flag.png[]

поля структуры базовой для потоков 


Когда завершаем поток `do_cancel` все равно вызывается (?)

== На человеческих ЯП 

```Java

class some {
    public void foo(){
        while(!t.isInterrupted())
        try{
            sleep(10);
        }
        catch(InterruptedException){

        }
    }
}
```
есть еще метод `::interrupted()` -- он возвращает флаг и сбрасывает его. IsInterrupted просто возвращает значение.



[cols="1,1, 1, 1"]
|===

|cmd 
|posix 
|c++11
|java

|Cancel (please)
|cancel
|none
|interrupt

|===


== boost 

имеет похожую логику. но у них свой флаг. значит они не смотрят на флаг посикса. и че там происходит нехорошее и в стандарт это не внесли

== cas  
compare and set -- атомарная операция сравнения и сета. реализована на уровне процессора. но в user space. блокирует шину.

Чеcтные примитивы синхронизации -- попадаем в kernel space. при нечестных -- нет.
Зачем при переходе переходим в kernel space.

== kernel space 
адресное пространство процесса ядра. там куча данных. структуры данных, алокатор памяти, планировщик, примитивы синхронизации. 

== user space 
прикладной код. при выполнении функций-системных вызовов (new, другое выделение памяти) это все через цепочку вызовов и использует интерфейс ОС из syscall системные вызовы -- реализация функций, описанных в стандарте POSIX. 

Код системной функции -- просто функция, но реализованная в ядре ОС. Просто вызвать его нельзя, т.к. он используетт методы ядра ОС, а обращаться к пространству другого процессора нельзя.

При выполнении syscall меняется контекст (регистры) и продолжается выполнение *того же* потока, но уже в kernel space. То есть код ОС выоплняет наш же поток. Это защищенное пространство, пользовательский код отсюда вызвать нельзя (чтобы нельзя было выполнять вредноносный код). После выполнения кода поток выныривает из kernel space и продолжает исполнение.

Выныривание и заныривание очень дорогая операция! частота процессора 10:9 процессорных инструкций. В секунду можно вызвать максимум миллион функций ОС из-за переключения контекста. Любой вывод -- это обращение к процессору, поэтому это так дорого.пока из всех преподов он и АМ круче всех рассказывают

=== Когда переходим в kernel space при захвате примитивов синхронизации? 

Зачем примитиву синхронизации провариваться в kernel space?  Если поток пришел и мьютех уже захвачен -- он говорит ОС, что он заблокирован и ОС ставит его в очередь заблокированных и не ставит на исполнение, пока ресурс не освободится.

=== Когда не нужно
Может не захватывать, если поток пришел и захватил примитив (установил флаг в мьютексе в своем адресном пространстве с помощью cas). 

А еще можем не вставать в очередь, а попытаться еще несколько раз захватить. Вдруг он освободиться.

cancellation point -- любой метод, где внутри вызывает thread_cancell(ed?). Если мы не будем его вызывать, то никогда не сможем завершить заснувший на год поток.
