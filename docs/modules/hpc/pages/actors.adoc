= Акторные модели 

Актор, ограничение:

* имеет уникальный адрес для отправки сообщений 
* может создавать новые акторы и получать их адреса 
* может изменять своё состояние (без координации с другими)
* нельзя взаимодействовать напрямую с другими акторами
* нельзя использовать один и тот же ресурс в разных акторах

Следствия: 

* не обязан останавливать выполнение для коммуникации
* среда может их запускать без потери производительности
* среда может управлять ресурсами (файлы (дескрипторы), сокеты)
* при крушении одного из авторов система в целом лучше сохраняет работоспособность

`+` можно удобнее писать многопоточку 

== Реализации
=== Наивная реализация 
* любой язык с многопоточкой
* актор: пара поток-очередь
* адрес: ссылка на пару

Все равно пролезть ссылками куда не нужно. Чтобы это решить можно притворится, что у нас персистентные объекты 

=== Безопасная реализация с виртуализацией 
* планирование
* управление памятью
* простая коммуникация 
* ввод/вывод

== Erlang (ирлАнг) & Beam VM 
Рожден в 80, opensource в 90

Процесс ниже -- это актор  

* персистентные структуры данных
* состояние процесса -- полностью в стеке 
* сообщения упорядочены в очереди => гарантируем порядок доставки
* получение сообщения -- явная операция (оператор языка `receive`)
* высокая масштабируемость (реально миллионы)
* можно именовать процессы (при регистрации) и обращаться к ним по имени

=== планировщик 
* полностью реализован в user space
* вытесняющий
* мультипроцессорный 

=== память 
* отдельный heap для каждого процесса 
* независимая сборка мусора 
* разделяемые области памяти: код, константы, считанные массивы байт
* ресурсы: привязываются к процессам создатели, освобождаются автоматически при смерти

=== недостатки 
* 80 годов => многословный, устаревший синтаксис

== Elixir 
* динамическая типизация 
* паттерн матчинг 
* метапрограммирование 


== OTP -- open telecom platform 

Стандартная библиотека erlang и beam  

Из слинкованных приложений может образоваться цикл. Поэтому здесь стараются структурировать зависимости между процессами в виде дерева.

Выделяем процессоры-супервизоры. Их единственная задача: следить за детьми, чтобы их структура была такая же как ожидает приложение.

Как правило, работающие ресурсы -- листья дерева.

Вводит 3 класса процессоров

=== GenServer 
выполняют прикладной функционал, умеют обмениваться сообщениями

=== GenSupervisor 
Получает конфиг с описанием дочерних супервизоров и серверов. Следят, чтобы актуальное состояние рантайма соответствовало конфигурации.

=== Application 
Общая обертка, которая связана с упаковкой и дистрибьюцией. Смотрит в конфигурацию/окружение/ОС и настраивает все суперивзоры.

== Пример 
приложение слушает tcp, возвращает сообщение тем кто достучался 

ресурсы: 

* сокет-слушатель 
* сокеты-отравители ответа

* PS -- супервизор над портами. Если они умерли -- он их не воскрешает (проблема скорее всего ниже, мы просто информируем о падении дальше)
* SS - Заводим еще один супервизор, который будет управлять процессом-сервером и другим супервизором. Перезапускает их при падении.
* Поверх него будет application


