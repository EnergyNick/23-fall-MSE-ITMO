= 5. Атомарные снимки регистров
 
Есть набор атомарных регистров. Регистр --  это просто ячейка в памяти для записи и чтения, никак не связанная с регистрами машин.

Считаем, что в регистр можно за одну операцию записать сколько угодно данных. Копируем структуру, меняем поле,  в цикле через cas меняем структуру обратно.

*Задача*: в lockfree стиле реализовать алгоритм снятия снимка атомарных регистров.

#Snapshot# -- снимок -- набор из значений регистра. Должен быть:

* *согласован* -- набор значений должен хотя бы когда-то существовать в одно мгновение в системе, чтобы система принимала согласованные решение на их основании
* *актуален* -- значение обязательно было после момента начала вызова метода `make_snapshot`; изначально регистры нулевые и это согласованное значение, но нам не подходит.

== Lock-free snapshot
Добавляем в регистр версию. Считываем до тех пор, пока два набора версий не станут одинаковыми. 

```c++
void scan(){
    a = collect(regs)
    b = collect(regs)
    if (a == b)
        return a;
    // repeat
}
```

[.pluses]
* Скорость: прочитать 10-100 регистров быстрее, чем "усыпить" процесс (захват примитива синхронизации -- порядка 10^3 тактов процессора).
* Данные более актуальны, т.к. у писателей больше прав

[.minuses]
* У писателей в регистры "больше прав", чем у читателя-scan.

== Unbounded wait free  
#Unbounded# значит, что размер версий неограничен

#Wait free#: потоки завершат свою задачу за n шагов, причем n зависит от размера данных, а не от количества потоков.

=== SWMR
Ограничение: каждый регистр -- Single writer/multiple reader


==== Запись регистр.

Писатель сначала делает снимок, а затем записывает его в свой регистр с инкрементированной версией.
Это wait-free, т.к. scan wait-free и в регистр пишет только 1 писатель.

```c++
void update(int reg, T data){
    snapshot s = scan();
    //тут могут пройти годы
    write(reg, data, v++, s);
}
```

==== Снятие снимков 
Делаем dummy снимок дважды. Если они равны, то состояние снимок согласован, возвращаем его. 

Если нет -- значит между dummy снимками была запись в регистр -- пусть это регистр I

image::snapshot/wf1.png[]

Но когда происходила запись, писатель тоже сделал снимок. Однако вернуть снимок писателя мы не можем. Писатель мог начать сделать снимок до вызова нашего метода: заснуть на год, проснуться и записать свои значения. В этом случае они будут *не актуальны*. 

image::snapshot/wf2.png[]

Читаем третий раз. Если снимок совпал с предыдущим -- возвращаем его.

image::snapshot/wf3.png[] 

Если не повезло -- значит между вторым и третьим чтением была какая-то запись,  например, во второй регистр II. Этот снимок, как и в прошлом случае, мог быть снят задолго до вызова нашего метода. Его тоже нельзя использовать.

image::snapshot/wf4.png[]

Читаем четвертый раз. Если снимки тоже не совпали, значит произошла повторная запись в одни из регистров (т.к. их в нашей системе всего 2). Но снимок в этом регистре сделан уже после вызова нашего метода, значит мы можем вернуть его как результат. 

image::snapshot/wf5.png[]

```c++
void scan(){
    r1 = read(regs);
    r2 = read(regs);
    if(r1.v == r2.v) 
        return r1;
    //иначе было событие-записи
    //значит где-то между ними мы сделали снимок
    //проблема в том, мы могли начинать делать снимок до вызова нашего scan
    r3 = read(regs);
    ...
}
```

Писатель снимает снимок и пишет в регистр, который изменяет. 

Когда делаем снимок -- итеративно сравниваем версии. Если они совпадают -- возвращаем результат. Иначе ищем какой именно регистр изменялся. 

Если изменяемый регистр записывается второй раз, значит его писатель начал делать снимок после начала нашего scan и значение актуальны. Можем вернуть значение снимка из этого регистра.


Wait free достигается за счет того, что в каждый регистр может писать только один поток. При этом алгоритм ограничен только количеством регистров. Для любого количества потоков-читателей за n+2 алгоритмов будет снят актуальный снимок .

==== Wait free плюсы и минусы

[.minuses]
* квадратичная память
* долгая запись, сложность не константная, а линейная
* ниже средняя производительность (в случае снимка -- заставляем писателя делать несвойственную ему работу)

[.pluses]
* снимок актуален, т.к. single writer.
* подходит для ОС жесткого реального времени ответственного применения (АЭС, самолеты и т.д.), т.к. можно гарантировать время отклика на сигнал. WF алгоритмы используются на уровне планировщика ОС.

Любой lock free алгоритм формально можно преобразовать в wait free. Чтобы этого достичь, потоки публикуют свои операции и помогают друг другу выполняться. Но это требует гораздо больше памяти и не всегда реализуемо на практике.

=== Bounded SWMR
Заменяем поле версии на битовый handshake, т.к. нам нужна не сама версия, а просто признак того, что произошли изменения.

==== Multi Writer MR
Алгоритм можно расширить до Multi Writer
Делим каждый регистр на два: данные и id потока, который сделал последнюю запись в регистр. Выделяем еще один регистр для каждого писателя, где-то хранится его snapshot. Изменения регситра просмтариваются 3 раза.

Но деталей мы не обсуждали.


=== Wait free  

`-`  много памяти 

`-` ниже средняя производительность 

`+` ОС жесткого реального времени


== Extra 
Снимок может быть полезен для реализации итераторов в lock-free структурах данных

Алгоритм снятия снимка разрабатывал Нир Шавит

image::snapshot/shavit.png[]