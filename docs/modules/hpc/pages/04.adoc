= Ошибки параллельного программироания 

== 1. Deadlock 
состояние приложения, когда и-за какой-то работы с примитивами синхронизации работа приложения никогда не пойдет.

=== 1. Нерекурсивные примитивы синхронизации
Нерекурсивные примитивы синхронизации (можно схватитать даже в одном потоке)

Как поймать?

a. просто хватаем дважды (рекурсивно?)
    ```
    b.lock()
    b.lock()
    ```

b. Есть обработка сигналов. Подписываемся на сигнал, вешаем обработчик. В каком потоке она поймается и обработается? 

Варианты 

1. main 
2. новый созданный поток, который join'ится 

    (во первых, не царское дело создавать новый поток. во вторых, наша логика может быть завязана на однопоточность)

3. поток, который подписался (sigaction).

     Нет, т.к. этот поток мог перестать существовать конда пришел сигнал.

4. случайный 

    (правильный ответ. приостанавливаем выполнение кода потока и подсовываем туда код обработчика. при создании потока в с++ можно задать флаг, что он не хочет обрабатывать потоки. если все против, то берем последний кто не успел отказаться. Поэтому лучше не писать сложную логику в обработчике сигналов. Можно делать какой-то флажок.
    
    Пример: залочили list, вызвались как оброботчик и очислити его. дальше работает с пустым листом и падаем. )

=== 2. Перекрестный 
1: 
a.lock()
b.lock()

2: 
b.lock()
a.lock()

Как чинить? Иерархическая блокировка. Обеспечиваем одинаковый порядков везде, сортируем примитивы (по алфавиту??)

Тем более мы профессионалы и хорошо инкапсулируем код, поэтому есть частичная организация. Поэтому образуется и общая.

Если между захватами есть локига, то нужно делать эту вручную.

Как нельзя исправлять?
1. Выставлять таймауты
2. Добавлять новые примитивы синхронизации, который отождествляет объединение этих двух. Так плохо, лучше бы мапить примитив к данным 1 к 1 

=== 3. Из форка многопоточных программ
Есть 1 процесс, в котором два потока. Так получилось, что в этом процессе есть еще примитив синхронизации и структура данных, ассоциированная с ним, чтобы он его защищал.

Второй поток захватил примитив.

Первый поток делает форк процесса. Появился второй процесс p2.

fork -- системный вызов, который создает еще один процесс, которыя является полной копией (адресного пространства, кучи и т.д.)

метод fork вернет в родиетеле id потомка, во втором -- исполнение начнется со строчки fotk, который вернет 0.

mutex копируется в текущем состоянии, т.е. в заблокированном (просто флажок).

Сколько потоков будет в форке? 1, копируется поток, в котором был вызван форк (стандарт ОС). Т.к. это единственный поток, который мы детерминированно и всегда одинаково знаем, откуда его запустить.

Если бы мы решили копировать все, то брали контексты всегда по разному, т.к. мы бы ловили их все время в разном состоянии. Поэтому повторяемости не было бы.

Если теперь форкнутый поток хочет захватить ресурс, то он никогда не дождется его освобождения (т.к. флаг "занят" и никто не может его освободить). Если поток взял ресурс и умер, но не отпустил, то ресрус в неконсистентном состоянии и не должен не достаться никому.

в Posix есть pthread_and_fork(* f_ptr1, * f_ptr2,  *f_ptr3) -- регистрация трех callback. Эта функция обеспечивает выполнение первой функции в рамках первого процесса до форка, второй в раках первого процесса после форка и третьего в рамках второго процесса после форка (до форка его еще не было) соответсвенно.

Как решать эту проблему? 

Захватываем на общем основании вообще все ресурсы. Отпускаем их в первом потоке и во втором. Но как второй процесс освободит ресурсы, ведь его поток уже с другим ID?

== Fork 
работает как корова 

второй процесс сначала физически ссылается на память своего предшественника. в таблице страниц виртуальной памяти для 1 и 2 потока указывают на одну память физическую, пока один из процессоров что-то не поменяет.
== Диагностика 
debugger, info_threads

gdb - p <proc_id> -- подключиться через отладчик к процессу 

valgrind (c++) имеет архитектуру vm, пробускает все вызовы через себя, смотрит память побайтово (valgrind --tool=helgrind kate) 


ошибка: `lock order violated`

Алгоритм поиска: журналирует захваты. Ограничения такого алгоритма

1. не может анализировать spinlock и пользовательские mutex.
2. не детектирует на сигналах
3. не все потоки исполнения анализируются: не детектит, если код не исполнялся
4. должен знать, что mutex -- это mutex
5. должен знать, что может быть потенциальный ???

2. 

== 2. Гонка данных (Data race)
Ошибки из-за несогласованнного конкурентного доступа к данным.

Примеры

1. Система 32 битная, но есть условные 64 битные структуры. Чтение может произойти, когда записана только первая часть. Считываем значение которого нет.
2. При копировании часть объекта скопировалась от одного объекта, а другая -- от другого того же типа. Этот объект может просто гулять по системе и мы его можем не увидеть. Получаем объект, которого нет.
3. Один байт x = 0. Делаем инкремент в разных потоках. Инкремент сложный, из трех операций `mov inc mov`. Можем получить ошибку: результат, который нельзя получить линейно.

 Приводит к понятию `линерализуемость`. Если есть параллельное исполнение и можно подобрать последовательный набор операций. Если есть хотя бы одно паралельное, которое не совпадает ни с одним линейным, то беда (или наоборот?).

Если мильон потоков пишет и читает в однобайтовую переменную без синхронизаций, есть ли тут гонка данных? 

 С точки зрения предметной области примера нет. Если хотя бы  1 поток инкрементирует, то уже гонка данных.

== false positive data trace 
Просто ищет объекты, которые пишут/читают без синхронизации.


```c++
class X {
    const int a;
    public: X(): a = 1{}
    void print(){
        create_thread(){
            std::cout << a;
        }
    };
}


int main(){
    X x;
    x.print();
}
```

В этом примере valgrind может обознать гонку данных. В одном потоке читение, в другом запись. Синхронизации нет. valgrind пишет о потенциальной гонке данных.


== 3. Инверсия приоритетов

Одноядерная система y: приоритет, k - ??

Три потока A, C, B  

mutex разделяют B, A. У mutex могут быть 2 состояния: unlocked (стартовое) b locked

image::04/inv_01.png[]

Если бы не было С, мы бы отдали управление потоку В и такой ошибка разрешилась бы быстрее.

По сути поток C выполняется на ядре больше, чем А. И фактически его приоритет выше.

Такой пример был в марсоходе. Была ОС жесткого реального времени VxWorks. Поток B -- был прикладным, что-то мерил. Поток А -- боркер обмена сообщениями, шина данных. У А и B имели общие примитивы (данные нужно считывать). С -- отвечало за связь с землей.

И поток С приводил к перезагрузкам системы. В ОС есть вотчдоги, которые срабатывают, если система стагнирует. Процесс стагнировал, связи с землей не было (он шел долго).

Как решать эту проблему? 

Когда приоритетный поток захватывает примитив синхронизации захватывает примитив, который захватил менее приоритетный процесс -- мы поднимаем меньший выше большего. Она даем ему приоритет, он исполняется и отпускает. Его приоритет снова понижается до предыдущего.