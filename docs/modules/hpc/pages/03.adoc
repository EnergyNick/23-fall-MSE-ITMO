= Примитивы синхронизации (20.10.2023)

`mutex` (mutual exclusion — «взаимное исключение) защищает ресурс. Понять, что для работы с файлом нужно захватывать `mutex` можно только из документации (в `Rust` не нужно)

Хранит `id` потока, которым был захвачен, чтобы его не мог освободить другой поток.

Под честным примитивом синхронизации понимаем тот, который переходит в `kernel_space`. Нечестные спинлочаться.

*Рекурсивный* примитив синхронизации -- когда объект можно захватывать в рамках одного потока несколько раз. Отпускать нужно столько раз, сколько захватили.

*Нерекурсивный* примитив синхронизации -- если захватить его дважды в рамках одного потока, то можно получить `deadlock`.

* ? Зачем вообще нерекурсивный примитив синхронизации? 
В некоторых ЯП нет нерекурсивных примитивов синхронизации (точнее, разницы между ними).

 1. В некоторых областях (и в старом коде) быстрее -- не нужно иметь счетчик захватов ресурса. Это является аргументом в жестких встраиваемых системах, чтобы выигрывать наносекунды.
 2. Уходит одна степень свободы совершить ошибку, немного проще с точки зрения отладки. 
 3. Условно дисциплинируют писать код хорошо: с тестами и т.д.


* ? Зачем нужен рекурсивный примитив синхронизации? 

Пусть у нас есть следующий объект:

```java 
class V {
    mutex m;

public: 
    int size(){
        m.lock();
        //считаем размер с учетом фазы луны 
        m.unlock();
    }

    void push_back(elem){
        m.lock();
        //потокоопасная логика
        if(size() > 0){
            reallocate();
        }
        m.unlock();
    }
}
```

 Можно пересчитывать количество каждый раз, а можно инкрементировать/ декрементировать при добавлении. Но там нужно думать, когда его делать по локам.


* Как сделать с нерекурсивным?

1. Делать size до блокировки: плохо, когда отпустим блокировку придет миллион потоков и все удалят. 
2. Реализовать без вложенности (кода больше)

```java
class V {
public :
    int size(){
        m.lock();
        unsafe_size();
        m.unlock();
    }
    void push_back(elem){
        m.lock();
        unsafe_push_back();
        m.unlock();
    }

private: 
    int unsafe_size(){
        //считаем размер с учетом фазы луны 
    }

    void unsafe_push_back(elem){
        //ничего не блокируем!!!
        unsafe_size();
    }
}
```

== Критерии выбора способа реализации
* *Тестируемость*: второй способ лучше с точки зрения выделения логики в отдельных методах,логика работы вынесена отдельно без примитивов синхронизации. Они `private`, но для тестирования их можно вынести в отдельную `скрытую реализацию` (шаблон проектирования `p_impl`, `pointer_impl`). 

 Стоит ли платить за тестирование объемом кода? Да, при мокировании мы используем не меньше кода: для него в боевом коде выделяется отдельный интерфейс, хотя других показаний для его выделения может и не быть (структуры иерархии и т.д.).

* *Поддерживаемость* -- легкость внесения изменений и рефакторинга (см. книжку Фаулера). Использовать другой примитив синхронизации, изменения способа вычислений. И думать про то, что в `push_back` обязательно нужно сохранить рекурсивный `mutex` не нужно.


== timed 
Ждем примитив только в течении какого-то времени. В некоторых книжках советуют таким способом решать дедлоки. ТАК ДЕЛАТЬ НЕ НУЖНО. 

image::03/timed_mutex.png[]


* Когда нужно использовать `timed_mutex` (`try_lock`)? 
 
 Когда это необходимо для предметной области. Например, пишем систему управления автомобилем. Видим, что что-то перебегает дорогу. Нужно захватить систему тормозов. Если не затормозить за две секунды, то можно уже и не тормозить.

 Пример поскучнее: когда есть низкоприоритетные задачи. Например, отправить ответ. Будем ждать либо пока его не освободят, либо пока не пройдет какое-то время.
 

== Shared mutex (ReadWriteMutex)

image::03/shared_mutex.png[]

== Cas (ассемблерная операция)
image::03/cas.png[]

== spin_lock

image::03/spin_lock.png[]

так реализован `yield`. Поток не будет заблокирован на процессоре и падать в `kernel space` и произойдет context switch в ядре ОС. При этом переходит в другое состояние и не блокируется

image::03/spin_lock_atomic_inc_java.png[]

* Когда его использовать? 
 
 Когда маленькая критическая секция. Когда больше одного числа, но есть необходимость в согласованной арифметике. 
 Нельзя использовать, если в нем есть длительная операция (любой системный вызов, lock, выделение памяти и т.д.)

В некоторых языках программирования (в Java) spin_lock явно не существует. В исходниках jdk есть. Jvm по статистике сама поймет, когда его использовать.

== RAII 
такой же ресурс: в конструкторах захватываем, в деструкторах освобождаем. В java аналог -- finally 

image::03/raii.png[]

== Futex
Это не примитив синхронизации, а то, что используется для их реализации. В реализации самих futex очень много `spin_lock`, чтобы поменьше выходить из `user_space`.

image::03/futex.png[]

== Барьер 
image::03/barrier.png[]

При ожидании чего-то освобождаем примитив синхронизации в функции `wait`. После ожидания снова ждем на общих основаниях.

* ГДЕ ТУТ ОШИБКА?

 вместо if должен быть while!!!!!

* Почему бы не сохранять count в локальной переменной? 
 
 Если 9 поток снимется с исполнения между 13 и 14 строкой, а потом вызовется 10 и разбудит всех, то 9 это пропустит и после того как выйдет из очереди он уснет навсегда. Мы никак не узнаем, что поток был прерван до того, как он уснул :))

 Кстати, внезапное пробуждение в этом случае может быть и помогло бы.

В java mutex и object это одно и то же. В c++ на один ресурс мб несколько примитивов синхронизации.
 
 пример: каждая труба отвечает за свой бассейн, но реагирует на событие: в главной трубе появилась вода. На `POSIX` этот пример не работает :)

image::03/example.png[]

== Что-то там оптимизации

Один примитив, много кондишнв 


У условной переменной (как и у мьютекса) есть список потоков, которые его ждут. Мв подвешиваем список условной переменной к списку мьютекса объекта.

?????????????????????

broadcast == notifyAll 

signal == notify -- каждый раз заново проваливаемся в kernel space 

 -Вы же профессиональные разработчики -- заметил Евгений.
 -Хватит нас в этом винить -- ответил Константин.

== Пример 

image::03/ex1.png[]

Скомпилируем файл и посмторим все библиотеки, которые он линковал (`ldd`)

`linux-vdso.so.1` -- это что!?? 1 -- значит, что линкуется в первой строке.

Библиотека, которая принудительно прилинковывается к любому исполняемому файлу чтобы исполнять ограниченный набор системных вызовов.

Некоторые системные вызовы не впадают в `kernel_space` (вроде как ничего страшного не должно произойти). Например, `get_time`. В виртуальной памяти есть место, куда ядро само выкидывает какие-то значения. Это место доступно любому процессу. Оттуда мы эту информацию и берем. 

Иногда эти оптимизации приводят к уязвимостям. 

Если перейти на сайт 

* В чем разница между `mutex` и `lock` 
 
 Академично mutex это mutex (А lock - это lock).

В нативных ЯП их различают жестко, т.к. `lock` -- это `RAII` -- то, что освобождает его в деструкторе и захватывает в конструкторе. Такая себе обертка.