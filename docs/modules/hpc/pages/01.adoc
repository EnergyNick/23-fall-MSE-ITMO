= Параллельное программирование =
== 1. Введение 
Тенденции развития вычислительных систем, обуславливающие необходимость применения распределённых (параллельных) методов вычислений

Нефункциональное требование: удовлетворить требуемый уровень производительности. Почти не смотрим на распределенные вычисления. В основном работаем на общей памяти.

Работаем с системами, которые генерируют огромное количество информации. Их обработка в реальном времени почти невозможна.

Требования к производительности бывают разные:

* снизить латентность (банковские системы и т.д.)
* посчитать огромный набор данных (астрономия, генетика и т.д.) без привязки ко времени.

== 2. Классификация параллельных систем 
Одно ядро. Как сделать многопоточность?

Расширение процессора -- добавление доп регистров и инструкций.

=== SIMD 
SIMD -- обрабатываем много потоков данных (разных) одним потоком инструкций. 

* I - instruction 
* D - data, 
* S - single, 
* M - multiply

=== MISD, SMP, MPP - ?

== 3. Современные высокопроизводительные системы
=== SSE 
`SSE` -- Streaming SIMD extensions 

Векторизация -- применение векторных инструкций (например, перемножаем два вектора)

В 2008 году добавили в SSE операции со строками, т.к. стали популярны текстовые протоколы взаимодействия (xml, json), сериализации/десериализации

=== Расширения процессора
* `AVX` -- advanced vector extensions (на что-то из этого подвязан даже TensorFlow)

Если запустить приложение, но расширения нет -- будет прерывание ОС и окошко (или лог в терминал) "неизвестная инструкция процессора".

* `MMX` -- multimedia (?) extensions -- работа с целыми числами (обработка цветов)

* `FPU` -- floating point unit

*Посмотреть мои расширения: `lscpu`*

image::01/my_extensions.png[]

=== Многоядерность ?

=== Узлы кластеров ?

== Процессы и потоки 
Процесс -- агрегирующая сущность, имеет хотя бы 1 поток, набор дескрипторов, ресурсов и т.д.

Поток -- выполняется на процессоре 

У процессоров есть отношение предок-потомок (образуют дерево: `pstree`). Корень - systemd (раньше был initd)

== Поток ==
Есть ли такое у потоков?  

В случае потоков никаких подобных отношений не существует. Поток создался -- и он независим от потока-родителя, который его создал.

В `ftree` запись `68*[\{zoom\}]` -- означает, что в процессе zoom запущено `68` потоков, не считая основного. Т.е. всего 69.

У потоков есть id, но команды "завершить поток процесса" нет, т.к. это внутреннее дело процесса.

Если подключимся к процессу через `gdb`, то можем узнать информацию о его потоках
`info threads`.

 Почему у systemd есть ребенок systemd? Мы сделали форк корневого процесса, чтобы из него безопасно запускать всякое другое.

== Закон Амдала ==

image::01/amdala.png[]

p - количество процессов 

stem:[alpha] - доля последовательного кода 

stem:[S_p] -- выигрыш в производительности при параллелизме.

==  Потоки ОС (POSIX) ==
`POSIX` -- стандарт, который определяет набор системных вызовов, из сигнатуру и поведение, которые должно поддерживать ядро ОС, чтобы быть posix-совместимой. 

`Posix-threads` --расширение к Posix, чтобы работать с многопоточность (`pthread_*`)

Пока его не было, при `pthread_create` создавался не новый поток, а еще 2 процесса: соседний и родительский.

== 5. Старт потоков Java 

Поток можно создать поток двумя способами

=== 1. Имплементировать интерфейс

```
class Some implements Runnable {

@overide 
run(...)
...
}
```

Передать экземпляр в объект класса thread 

```
Thread t(SomeRunable)
t.start()
```

=== 2. Наследоваться от Thread

```
Some extends Thread {
    override run()
}
```
[.minuses]
* Тут теряем возможность наследования от другого класса.  

* Не можем повторно использовать наши объекты, которые создали для вычислений.


== Extra 
=== Предок-потомок
Доказываем, что у процессов есть отношение предок-потомок 

1. Запустили калькулятор. Усыпили его и перевели в фоновый режим `bg` (background).
2. Посмотрели текущий `id` процесса интерпретатора, через который мы запустили компилятор. `echo $$`. Проверить: `ps -ax | grep <pid>`.
3. Запустим калькулятор из нового окна консоли (с амперсандом, т.е. в фоновом режиме ~ bg).

 yakuake - выпадающий терминал. И в рамках его видим, сколько процессов запущено в системе (число - арность - сколько запущено). Это доказывает существование отношения предок-потомок между процессами. Т.е. реально вызывается fork -- делает копию процесса из текущего процесса.

4. Убьем второй процесс баша (из которого запускали с амперсандом) `kill -9 <pid>` (флаг 9 посылает сигнал `sigkill`, по умолчанию `sigterm`, который процесс может игнорировать). Теперь процесс баша исчез.
Баш погиб, но его потомка-калькулятора усыновил главный (корневой) процесс. Не предок-предка! А корневой.

 Зомби - процессы, которые не могут умереть, т.к. код их возврата важен какому-то предку.

5. Убьем первый интерпретатор. Его калькулятор тоже повиснет на `systemd`.
6. Запустим калькулятор, остановим (`ctr+Z` -> сигнал `sigstop`, его не поставят на исполнение на ядре процессора), узнаем код текущего процесса и вернем его калькулятор (`fg` ~ `foreground`).  Убьем консоль. Калькулятор убился совсем.
