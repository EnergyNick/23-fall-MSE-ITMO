==
* final поля в конструкторе и все, что по дереву из них можно достать (если final не покидает конструктор)
=== 1
JMMJavaMemoryModel(JMM) описывает поведение потоков в среде исполнения Java. Модель памяти —часть семантики языка Java, и описывает, на что может и на что не должен рассчитывать программист, разрабатывающий ПО не для конкретной Java-машины, адля Javaв целом.Исходная модель памяти Java, разработанная в 1995 году, считается неудачной: многие оптимизации невозможно провести, не потеряв гарантию, что код безопасен. В J2SE 5.0 (30 сентября 2004) появилась новая модель памяти, разработанная через JavaCommunityProcessпод названием JSR-133. Она лучше отражала принципы работы современных процессоров и компиляторов, и другие языки брали идеи из модели Java(схожая модель используется в С++11).

Это набор гарантий, который позволяет нам как программистам на что-то рассчитывать

=== Модель памяти
На уровне процессора, модель памяти определяет необходимые и достаточные условия для гарантии того, что записи в память другими процессорами будут видны текущему процессору, и записи текущего процессора будут видимы другими процессорами. Некоторые процессоры демонстрируют сильнуюмодель памяти, где все процессорывсегда видят точно одинаковые значения для любой заданной ячейки памяти. Другие процессоры демонстрируют более слабуюмодель памяти, где специальные инструкции, называемые барьерами памяти, требуются для «сброса» (flush) или объявления недействительными (invalidate) данных в локальном кэше процессора, с целью сделать записи данного процессора видимыми для других или увидеть записи, сделанные другими процессорами

Зачем? Гарантии. 

Python дает *сильные* гарантии: всегда работает только 1 поток. Но ошибки все равно могут быть.

В C гарантии перекладываются на железки и стандарты.

=== Видимость (visibility)
Изменения, которые где-то произошли увидели или нет в другом месте:

* кеши 
* Reordering: представление команд (интерпретатор, компилятор)

Один поток может в какой-то момент временно сохранить значение некоторых полей не в основную память, а в регистры или локальный кэш процессора, таким образом второй поток, выполняемый на другом процессоре, читая из основной памяти, может не увидеть последних изменений поля. И наоборот, если поток на протяжении какого-то времени работает с регистрами и локальными кэшами, читая данные оттуда, он может сразу не увидеть изменений, сделанных другим потоком в основную память.

=== Reordering
Для увеличения производительности процессор/компилятор могут переставлять местами некоторые инструкции. С точки зрения потока, наблюдающего за выполнением операций в другом потоке, операции могут быть выполнены не в том порядке, в котором они идут в исходном коде. Так же эффект может наблюдаться, когда один поток кладет результаты первой операции в локальный кэш, а результат второй операции кладет непосредственно в основную память. Тогда второй поток, обращаясь к основной памяти может сначала увидеть результат второй операции, и только потом первой, когда все кэши синхронизируются

=== Reordering
Еще одна причина reordering, может заключаться в том, что процессор (или компилятор!) может решить поменять порядок выполнения операций, если, например, сочтет что такая последовательность выполнится быстрее и не изменит семантику программы

== Volatile
* сразу обновляется в кеше 
* дает некоторые гарантии на reordering
* атомарный конструктор
```java
x = new X()
```

Рассахариться в 
```java
alloc map
const ruct 
x = ref 
```

Т.е. записываем в volatile и переставлять нельзя

Если x не volatile, то конструктор не атомарный и мы можем переставить операции в нем. Тогда если в другом потоке проверили 

```
if(x != null)
read(x)
```

То x уже не null, но еще не инициализирован и можем прочитать мусор.



== Happens-before
Есть два потока. На процессоре выполняются какие-то команды. X и Y связаны отношением hb, если Y и все то после нее видят результат X и все что до нее.

Это не про строчки кода, а про команды на процессоре. Можно ли гарантировать порядок инструкций на процессоре? Да, hb есть и в рамках одного процесса.

hb гарантирует сброс кеша (промежуточных данных не видно)

В JavaMemoryModel введена такая абстракция как happens-before. Она обозначает, что если операция X связана отношением happens-before с операцией Y, то весь код следуемый за операцией Y, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции X.

Связь happens-before транзитивна, т.е. если X happens-before Y, а Y happens-before Z, то X happens-before Z.

=== Синхронизация и мониторы

Соотношением hb связаны

==== Захват монитора 
(начало synchronized, метод lock) и всё, что после него в том же потоке. Это захардкожено прямо в компиляторе и явно запрещены reordering. При использовании  sync все hb до закрытия скобочек (даже то, что было до начала sync).

МОЖНО

* сверху вносить в критическую секцию
* снизу вносить в критическую секцию

НЕЛЬЗЯ 

* выносить изнутри наружу
* выносить код до синка после синка

==== Возврат монитора 
(конец synchronized, метод unlock) и всё, что перед ним в том же потоке. Все, что в критической секции выполняется до возврата монитора. Чтобы гарантировать видимость переменной нужно захватить монитор, захватывая который данные изменяли в другом потоке, т.к. они hb. Тут именно возврат монитора, а не отпускание в wait!!!

Таким образом, оптимизатор может заносить строки в синхроблок, но не наружу.

* Возврат монитора и последующий захват другим потоком. 

=== Зависимости по данным
* Любые зависимости по данным (то есть запись в любую переменную и последующее чтение её же) в одном потоке. Запись и последующее чтение переставлять нельзя.

* В одном потоке *перед* записью в volatile-переменную, и сама запись. Жесткий костыль: если меняем volatile переменную, то ее нельзя переставлять выше в reordering (ниже можно). Все в коде, что до нее -- выполняется до нее.
* volatile-чтение и всё, что *после* него в том же потоке. Чтение нельзя переставить ниже!!!
* Запись в volatile-переменную и последующее считывание её же в другом потоке. В примере во втором потоке мы гарантировано увидим value = 42 даже без блокировок!!!

image::media/08.png[]

* Для объектных переменных (например, volatileListx;) столь сильные гарантии выполняются для ссылки на объект, но не для его содержимого.

==== volatile 
* атомарный конструктор -- следствие hb!!! 

```java
alloc m 
constructor 
//вот тут запись в volatile! все что до -- нельзя переставлять.
x = ref
```
* значение сразу записывается в память -- следствие hb (при чтении volatile ждем окончания ее записи в другом потоке)

=== Обслуживание объекта
* Статическая инициализация и любые действия с любыми экземплярами объектов.Выполняется 1 раз, ее видно во всех потоках => гарантируется, что будет инициализирована до любого использования. Где-то выполняется и связывается hb со всеми потоками.

Как? Не ясно. Нельзя даже ответить, где именно выполняется инициализация. JVM может даже делать это внутри предварительно (опережающая реализация) и скрывать от нас ее результаты.

* **Запись в final-поля** в конструкторе и всё, что после конструктора. После выполнения конструктора гарантируется видимость final полей. Остальные все равно можно переставлять.

```java
alloc(m);
constructor();
final = some;  
//вот тут запись в final! все что до -- нельзя переставлять.
x = ref
```

  Как исключение из всеобщей транзитивности, это соотношение happens-before не соединяется транзитивно с другими правилами и поэтому может вызвать межпоточную гонку.

* Любая работа с объектом и finalize().
* Запуск потока и любой код в потоке.•Занулениепеременных, относящихся к потоку, и любой код в потоке.•Код в потоке и join(); код в потоке и isAlive() == false.•interrupt() потока и обнаружение факта останова.


=== 11
image::media/11.png[]
Happens-before В отношении happens-before есть очень большой дополнительный бонус: данное отношение дает не только видимость volatileполей или результатов операций защищенных монитором или локом, но и видимость вообще всего, что делалось до события hapens-before.

=== Публикация объекта
Публикацией объектов называется явление, когда один поток создает объект и присваивает на него ссылку какому-нибудь полю, которое может увидеть второй поток. Если запись в это поле первым потоком, разделена со чтением этого поля вторым потоком отношением happens-before, то публикация называется безопасной, т.е. второй поток увидит все поля опубликованного объекта, инициализированные первым потоком.Есть еще один способ добиться безопасной публикации объектов: если ссылка на объект, все поля которого являются final, становится видимой любому потоку, то данный поток видит все finalполя, инициализированные во время создания объекта. Более того он будет видеть все значения достижимые из finalполей

=== Публикация объекта

```java
public class AlwaysSafePublished{
    private final Map map=newHashMap();
    public AlwaysSafePublished() {
        Collectionc=newArrayList();
        c.add("a");
        c.add("A");
        map.put("1",c);
        }
    public int number(){
        return map.get("1").size();
    }
}
```
Java гарантирует, что все модификации с final полями и все, что мы по дереву можем из них достать (модификация или access) -- будут инициализированы. ТОЛЬКО В КОНСТРУКТОРЕ. Как? Неизвестно. Поэтому `number` гарантировано выдаст двойку.

Гарантируется только если ссылка на final не покидает конструктор. 

В этом примере транзитивность не гарантируется (не понятно как это обеспечить в таком сложном механизме).

=== Публикация объекта
Если кроме как ссылок final на ваши объекты никто не ссылается, тоне зависимо от уровня вложенности,поток, который видит ссылку на опубликованный объект, увидит все значения достижимые через finalполя, которые были выставлены в конструкторе. Так в примере, любой поток, успешно зашедший в методnumber, всегда вернет значение 2. Конечно при условии, что после конструктора содержимое всех объектов больше не модифицируется.Это делает singleton на double-checkработоспособным.Все это верно только для объектов, во время конструирования которых, ссылка на объект не покидетконструктор, прежде чем он завершен.

=== 15 
Атомарность записи-чтения полейJMM гарантирует атомарность записи-чтения всех не long/doubleполей. А volatile-абсолютно всех полей. Поля, представляющие ссылки на объекты, тоже всегда пишутся-читаются атомарно. Спецификация не запрещает иметь атомарность записи чтения long\doubleполей для 64-битной виртуальной машины. Данная атомарность гарантирует, что любой поток в любой момент времени зачитает из поля либо значение по умолчанию, либо полное значение, записанное туда в некий момент времени, и никогда не найдет там какого-то мусора

== JCStress 

Как тестировать многопоточную программу, чтобы оно все не исполнялось на одном потоке? 

1. Формальная верификация (достижимость, недостижимость)
2. Многократный запуск одного и того же кода и анализ статистики.

`JCStress` занимается вторым. Разрабатывался для тестирования JVM. Можно задать ожидаемые результаты.

`actor` -- отдельный поток, который будет запущен в рамках теста. Им передаются объекты Result, в которые можно что-то записать.

`outcome` -- допустимые при выполнении результаты. Тесть пройден, если результат ему принадлежит.

```java
public class VolatileTest{
    @JCStressTest
    @State
    @Outcome(id = "[1, 2]", expect = Expect.ACCEPTABLE, desc= "T1 updated, then T2 updated.")
    @Outcome(id = "[2, 1]", expect = Expect.ACCEPTABLE, desc= "T2 updated, then T1 updated.")
    @Outcome(id = "[1, 1]", expect = Expect.ACCEPTABLE, desc= "Both T1 and T2 updated concurrently.")
    
    public static class VolatileIncrementAtomicityTest{
        volatile int v;
        @Actor public void actor1(IntResult2 r) {r.r1 = ++v;}
        @Actor public void actor2(IntResult2 r) {r.r2 = ++v;}}}
```

Результат по каждую outcome:
```
(fork: #1, iteration #1, JVM args: [-server])
Observed state Occurrences Expectation Interpretation

1,  1 1,543,069 ACCEPTABLE Both T1 and T2 updated concurrently.
1, 2 29,034,989 ACCEPTABLE T1 updated, then T2 updated.
2, 1 26,223,172 ACCEPTABLE T2 updated, then T1 updated.
```
== Мифы 
=== 1. Компьютер делает ровно то, что мы его просим

```java
int m(){
    int a =42;
    int b =13;
    intr = a + b;
    return r;
}
```
Соптимизируется в 

`mov%eax, 55;
ret`

* Оптимизация есть во всех языках.
* Наблюдаемый результат выполнения –- один из результатов выполнения абстрактной машины. ]
* Внутри может происходить все что угодно.

* Когда происходит debug, дебаггер (говорит "штош" и ) пытается реконструировать пошаговое выполнение. В случае с Java дебаггеробычно эмулирует состояние абстрактной Java-машины, нежели лезет во внутреннюю работу JVM

Таким образом, если JMM говорит о каком-то порядке выполнения это не значит, что физическая имплементация выполнения кода не может опускать какие-то инструкции...

```java
volatile int x;
void m(){
    x = 1;
    x = 2;
    System.out.println(x);
}
```

В примере здесь выпиливание строчки `x = 1` не портит JMM. И в `println` может быть захардкожена двоечка. НЕСМОТРЯ НА ТО ЧТО x volatile.

```asm
mov%eax, 2 # first argument
call System_out_println
```

=== Миф-2
Барьеры –- действительно барьеры

`get_this_in_order` -- запрещает перестановку команд (`JCStress`)

```java
@JCStressTest
@Statepublic
class SynchronizedBarriers{
    int x, y;
    
    @Actorvoid actor() {
        synchronized(this) {x= 1;}synchronized(this) {y= 1;}}@Actorvoidobserver(IntResult2 r) {// Caveat: get_this_in_order()-s happen in program orderr.r1 = get_this_in_order(y);r.r2 = get_this_in_order(x);}}
```

```(fork: #1, iteration #1, JVM args: [-server, -XX:+UnlockDiagnosticVMOptions, -XX:+StressLCM, -XX:+StressGCM])Observed state Occurrences Expectation Interpretation0, 0 43,558,372 ACCEPTABLE All other cases are acceptable.0, 1 22,512 ACCEPTABLE All other cases are acceptable.1, 0 1,565 INTERESTING X and Y are visible in different order1, 1 1,372,341 ACCEPTABLE All other cases are acceptable.
```

Как получить y = 1, x = 0? Между акторами не гарантируется hb. И переменная x после присваивания валялась в кеше первого потока. 

Нельзя выносить задачи из sync, но можно внести второй в первый и соптимизировать второй sync. Теперь у нас один синк с двумя инструкциями, которые можно переставлять между собой. Поэтому мб сначала посчитать `y`, а потом `x`. 


 
=== Миф-3 

Нельзя мыслить категориями «локальный кешпотока» и «главная память» 

```java 
@JCStressTest
@State
classIRIW {
    int x;
    int y;
    
    @Actor
    void writer1() {x= 1;}

    @Actor 
    void writer2() {y= 1;}
    
    @Actor
    void reader1(IntResult4 r) {r.r1 = x;r.r2 = y;}
    
    @Actor 
    void reader2(IntResult4 r) {r.r3 = y;r.r4 = x;}}
```

Интересный случай: 1 0 1 0. Как такое могло получиться? Переставились инструкции. 

 1, 0, 1, 0 152 ACCEPTABLE Threads see the updates in the inconsistent order


UNSAFE.fullFence() -- барьеры. Считаем, что это гарантирует отсутсвие перестановок. Не надо так писать.
  
```java 
@CStressTest
@State
public class  FencedIRIW
{   int x;
    int y;
    
    @Actor
    public void actor1() {
        UNSAFE.fullFence(); 
        x= 1;
        UNSAFE.fullFence(); }
    @Actor
    public void actor2() {
        UNSAFE.fullFence(); 
        y= 1;
        UNSAFE.fullFence(); }
    @Actor
    public void actor3(IntResult4 r) {
        UNSAFE.loadFence(); 
        r.r1 = x;
        UNSAFE.loadFence(); 
        r.r2 = y;
        UNSAFE.loadFence(); }
    @Actor
    public void actor4(IntResult4 r) {
        UNSAFE.loadFence(); 
        r.r3 = y;
        UNSAFE.loadFence(); 
        r.r4 = x;
        UNSAFE.loadFence(); }}
```

 1, 0, 1, 0 47 ACCEPTABLE Threads see the updates in the inconsistent order

Здесь 1 0 1 0 все равно возможен. Можно обосновать с помощью менеджера памяти, который нам рисовали: х уполз слишком далеко и мы его уже не видим. 


```java
@JCStressTest
@State
public class VolatileIRIW{
    volatile int x, y;
    @Actor 
    public void actor1() {
        x= 1;}
    @Actor 
    public void actor2() {
        y= 1;}
    @Actor 
    public void actor3(IntResult4 r) {
        r.r1 = x;r.r2 = y;}
    @Actor 
    public void actor4(IntResult4 r) {
        r.r3 = y;r.r4 = x;}
```

Здесь увидеть уже нельзя: если записали volatile, то гарантировано увидим его после. И volatile запрещает перестановки и всякое.

1, 0, 1, 0 0 ACCEPTABLE Threads see the updates in the inconsistent order

ACCEPTABLE -- он возможен, но 0 способов так сделать.

== Паттерн "Контейнер"
```java
classB<T> {
    T x;
    publicvoidset(T v ){
        synchronized(this) {
        x= v;
        } 
    // "release" on unlock
    }
    publicT get() {synchronized(this) { // "acquire" on lockreturnx;}}}
```
Все работает, можно сделать и по другому 

```java 
classB<T> {volatileT x;publicvoidset(T v) {x= v; // "release" on volatile store}publicT get() {returnx; // "acquire" on volatile load}}
```
== Volatile => можно не думать?
Arbiter -- поток, который стартует после того, как отработают акторы.

**пример с циклами**

Как получить 2? Поочереди

Можно ли получить 1?  Нет, но почему?

=


=== 
=== 
=== 
=== 
=== 
=== 
=== 

Задание (большое):

Представим, что написали некоторый сетевой сервис, который обрабатывает запросы клиентов.

При этом наша ситуация такая, что запросы клиентов исполняются на сервере значимое время и требуют больших вычислений.

Сервер можно организовывать разным количеством способов, хочется понять: как это лучше сделать. Для определения этого смотрим метрики.

Метрики

* задержка 
* пропускная способность
* время отклика системы


|network|T_server|network|client|

Из времени сервера он активно обрабатывался какую-то его часть (в засимости от нагрузки, количества ядер, слишком частое переключение контекста)

Задача: ппостроить приложение, которое 

1. Позволит разворачивать такую хрень
2. На сервере реализовывать определенное количество сетевых архитектур
3. Собирать статистику
4. Отвечать, почему ответ именно такой

