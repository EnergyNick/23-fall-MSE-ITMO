= Умные указатели
== Box<T> ~ Unique ptr 

* Владеет данными на куче
* Аналог std::unique_ptr<T> из мира C++
** Хранит в себе указатель
** При разрушении уничтожает данные за указателем
* в отличие от unique_ptr<T>
** сохраняет мутабельность: нельзя изменять данные за неизменяемым Box<T>
** Не может быть null

Зачем хранить данные на куче? 
* хранение данных неизвестного размера
* хранить большой объект без копирований 
* хранение рекурсивных структур
```rust 
Box<T>: пример
fn foo(x: &usize) { ... }
let bx = Box::new(42);
foo(&bx); // разыменование
*bx = 43; // ошибка: bx иммутабелен, разыменовать нельзя
let mut bx = Box::new(42);
*bx = 43; // теперь переприсвоение возможно
```

== Rc<T>, Arc<T>
Аналоги std::shared_ptr<T>

Хранят указатель на данные и счетчик ссылок
*  При клонировании указателя (Rc::clone()) счетчик ссылок увеличивается на 1
* При разрушении указателя он уменьшается на 1
* При достижении нуля данные уничтожаются

Умеют отдавать лишь иммутабельную ссылку на данные

Отличие Rc<T> от Arc<T>?
* Rc = reference counted, если его передать в многопоточный код -- он не скомпилируется 
* Arc = atomically reference counted, для многоопоточных программ

=== Как взять мубательную ссылку?
* fn get_mut(this: &mut Rc<T>) -> Option<&mut T>
**Возвращает мутабельную ссылку на данные, если это единственный Rc

* fn make_mut(this: &mut Rc<T>) -> &mut T

** Если Rc<T> единственный — возвращает ссылку
** Иначе делает копию данных и возвращает ссылку на копию
** Получаем copy on write (он же COW)

=== Применение
* Почти сборщик мусора
* Полезно для объектов, для которых непонятно, кто должен владеть
* Еще нужен для copy-on-write

=== Проблемы 
Пусть у нас есть
```Rust 
struct Foo {
next: Option<Arc<Foo>>,
value: usize,
}
```
При этом есть два Arc<Foo>, которые указывают друг на друга
Утечка? Да, но считаем что soudness сохранена

== Weak<T> 
Есть слабые ссылки (от слабых указателей) и сильных ссылок (от использования).

Можем разыменовать только если есть слабые ссылки. Удаляет объект, когда кончились сильные ссылки.

== Cow<T> 
to_mut -- либо отдает объект, лбо копирует и отдает копию

=== ToOwn

aaaaa

== trait Deref (*)
разыменование в умных указателях (*, &)

pub trait Deref {
    //targe -- во что разменовывать
type Target: ?Sized;

●
●
fn deref(&self) -> &Self::Target;
}
pub trait DerefMut: Deref {
fn deref_mut(&mut self) -> &mut Self::Target;
}
Реализация Deref и DerefMut позволяет использовать оператор * для
умных указателей

== Неявное преобразование 
deref -> target

Теперь разберем еще один старый пример:
let val = Arc::new(vec![1, 2, 3]);
let r: &Vec<usize> = &val; // разыменование
println!("{:?}", r);
println!("{}", val.get(0).unwrap()); // работает вместо (&val as &Vec<usize>).get(0)
Здесь используется неявное приведение ссылок:
○
 &T для T: Deref преобразуется в &T::Target
○
 &mut T для T: Deref преобразуется в &mut T::Target
То же самое работает и для методов:
○
 Если у &T::Target есть метод, то его можно вызвать и через &T
○
 Если у умного указателя и объекта, на который он указывает, есть одинаковый метод, то
будет вызван метод умного указателя
○
 Правило работает транзитивно, до тех пор, пока метод не найдется!

```rust
struct A(...);
impl A {
fn a(&self) { println!("A::a"); }
fn d(&self) { println!("A::d"); }
}
struct B(...);
impl B {
fn b(&self) { println!("B::b"); }
fn d(&self) { println!("B::d"); }
}
impl Deref for B { type Target = A; ... }
struct C(...);
impl C {
fn c(&self) { println!("C::c"); }
}
impl Deref for C { type Target = B; ... }
```
можем вызвать с.а()
При конфликте вызывается тот, что раньше

Еще всякое 

```rust 
let a: A = ...;
let b: B = ...;
let c: C = ...;
c.a(); // A::a (двойной Deref!)
c.b(); // B::b
c.c(); // C::c
c.d(); // B::d (т.к. он найдется раньше, чем A::d)
b.d(); // B::d
(&*b).d(); // A::d (явно зовем внутренний метод)
(&b as &A).d(); // A::d (так тоже можно!)
```

== Деструкторы

Реализуются трейтом Drop:
pub trait Drop {
fn drop(&mut self);
}

сначала дроп от структуры, потом от ее полей.

Нет гарантии вызова:
* Утечки памяти
* Паника в деструкторе
* Экстренное завершение программы

 std::mem::forget<T>(t: T)
■ Является safe!

Вопрос: почему в Rc<T> нужна проверка на переполнение счетчика
ссылок?


