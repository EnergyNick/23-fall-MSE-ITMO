= Многопоточное программирования 

== thread примеры 

`send` -- T  должен безопасно переживать, что его перемещают между потоками

`'static` -- должны отсутствовать lifetime зависимости. никаких ссылок borrow checking кроме как из константных источников

`trait Sync` -- 


```rust 
std::thread::spawn
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
F: FnOnce() -> T,
F: Send + 'static,
T: Send + 'static;

JoinHandle<T>:
    //result, тк поток может запаниковать
    pub fn join(self) -> Result<T>;
    //если тут унврап, то паника запропогируется на потоки
```

Пример: числа Фибоначчи
```Rust
fn parallel_fib(n: u64) -> u64 {
    if n == 0 || n == 1 {
        return 1;
    }
    let t1 = thread::spawn(move || fib(n-1));
    let t2 = thread::spawn(move || fib(n-2));
    t1.join().unwrap() + t2.join().unwrap()
}
```

== 2. Гаранти safety. Send & Sync
Оба трейты маркерные, используются только на уровне системы типов. Размер ссылки не увелияивают.

Safe Rust гарантирует отсутствие data races, которые определяются как:

* Два или более потока одновременно работают с областью памяти
* Один или более из них пишет в эту область памяти
* Один или более из них не синхронизирован


Race condition -- может быть несколько вариантов исполнения, но они все валидны.

=== Send 
Тип является Send, если его можно безопасно мувать между потоками.

Деструктор может быть вызван где угодно

Типичные способы передать объект в другой поток (высокоуровневое объяснение):

* thread::spawn(f) - передаёт замыкание f вместе со всеми захваченными значениями. F будет исполнено в другом потоке

* mpsc::channel() - создаёт канал

Send: формализация
Send разрешает такой паттерн доступа:

1. Объект создан в потоке Т1
2. Строго после этого публичное API объекта использовано потоком Т1
3. Строго после этого публичное API объекта использовано потоком Т2
4. ...
5. Строго после этого деструктор объекта исполнен потоком Tn (любым!!! Rc так не умеет)

=== Sync
Тип является Sync, если ссылку на него можно передавать между потоками
(&T: Send) ссылка на send -- sync
Sync разрешает такой паттерн доступа:

1. Объект создан в потоке Т1
2. Строго после этого константное публичное API объекта использовано потоком Т1
3. Конкурентно с этим константное публичное API объекта использовано потоком Т2
4. ...
5. Все потоки  > 1 перестали пользоваться объектом 
6. Строго после этого деструктор объекта исполнен потоком T1 (в котором создали!!!)