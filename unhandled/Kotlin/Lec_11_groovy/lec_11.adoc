= Groovy 
как питон

duck typing

опциональная типизация. Поломки все равно во время рантаймы.

== Структура исходника 
пакеты и классы. не должно быть класса с именем файла, т.к. глобальный класс создается неявно. Неявный класс импортировать нельзя (в отличии от питона), только методы и классы

на самом деле система классов как у джавы. И каждый файл -- это класс! Можно вызвать this

можно дописать расширение через точку (динамически расставит)

== methodMissing(String name, args)
этот метод вызовется, когда мы вызываем метод, для которого в проекте не нашлось подходящего по сигнатуре. Там уже можно паттерматчиться по имени метода и выполнять доп логику

метод не статический, может быть у каждого объекта свой

== Приколы 

* *коллекции* -- расширенные обертки из джавы, беды с мапами коллекций

* мапы -- можно использовать как структуры 

```groovy
John = [name: "Jojo", id: "123"]
Jhon["name"]
Jhon.name
```

* сетеры/гетеры можно переопределять, просто правильно назвать!

== Динамика в JVM  : Как в jvm представлять расширения классов? 
*invokeStatic* -- вызвать статический 

*invokeSpecial* -- конструкторы, приватные методы

*invokeVirtual* -- для вызовов через интерфейс и для обычных методов

=== Cтатический метод

Делаем метод, у которого аргумент-object. Но если это хранить как имя:класс, то в рантайме упадем. Поэтому можно испольовать статический рантайм метод, который будет принимать сигнатуру метода и разрешать.

`--` медленно 

`--` плохо для `jit` 

=== invokeDynamic

механизм вызова с `JDK7`, этот вызов невозможно породить из java-кода. С 8 джавы можно (в лямбдах).

`--` тяжело породить ассемблер для `invokeDynamic`

Через `MethodHandles` можно динамически искать классы в рантайме. Через `findVirtual`/`findStatic`/`findSetter`/`findGetter`

Отличия от рефлексии: 

* реализована по разному, рефлексия идет в нативный стек -- дорогая 
* рефлекция дает информацию о классе в целом, MethodHandle -- только о методе. 
* при lookup фиксируется контекст, откуда он вызывается: приколы с приватностью.

*CallSite* -- связывает `MethodHandler` и `invokeDynamic` (как операцию байткода). Чтобы следующие `invokeDynamic` делать быстрее. При первом вызове `invokeDynamic` вызывается специальный `bootstrap` метод (принимает MethodHandle.lookup, имя и сигнатуру метода), который находит и возвращает `CallSite`

== Перехват методов: GroovyIntercaptable 
Интерфейс с методом `invokeMethod(String name, Object args)`, который будет вызываться вместо всех методов интерфейса. Отсюда методы класса можно вызвать через поле `metaClass` -- есть у всех методов. 

Есть вариант сделать это через java api (super.getClass...)

== Расширения чужих классов
1. Как в ламе можно через ServiceLoader (+ какой-то внешний файлик)

2. Какие-то категории  -- по сути джава библиотеки

3. invokeMethod для одного объекта (видимо теперь у него другой метакласс). Можно сделать через класс Tracker

4. Просто создать расширение у метакласса CharSeguence.metaclass.foo = {123}. На них есть виртуальность!! Правильно вызывает расширение у наследникоов.