= Асинхронщина

== Async/await

Есть awaitAll для списка Defered
Но он привередлив в плане исключений
Одно падение - падение всего сразу
Если это не устраивает - надо отдельно
обрабатывать

`--` из коробки нет последовательной обработки всего

== Flow -- не корутина!! Это реактивная структура
=== Мотивирующий пример 

* Есть сервис работы с пользовательскими сообщениями
* Есть микросервис, отвечающий за историю сообщений
* Можно отправить REST-запрос и получить фрагмент истории полученных пользователем сообщений
* Параметры запроса - id пользователя и границы временного окна
* Как offset/limit или как временной диапазон
* Можно указать id отправителя


emit -- suspend метод 

он работает в той же корутине, но сохраняет место где выполнялся и возвращает каждый раз значччение как yield в итераторе

объект flow не создается, пока не будет вызван collect 

при повторном вызове collect начинаем проходить структуру сначала (создается новый объект?)

как над мапами в стриме здесь есть методы: терминальные (first) и нетерминальные 

==== есть отдельные реактивно специфичные 

debounce -- получает временной интервал, если между emit прошло меньше времени -- он отбросит старые. Вернет последнее, когда пройдет таймаут ("стабилизация") 

sample -- делит время на интервалы и возвращает последнее из временной шкалы


runningFoldl, runningReduce

===== callback специфичные 
onEach, onStart, onEmpty, onCompletion 

внутри них можно вызывать emit (дописать что-то в начало или конец)

===== launchIn 
Запуск в собственной корутине, чтобы можно ыло делать cancel 

принимает контекст

cancelable() -- будет проверяться на отмену при каждой emit -- если у нас нет вызово suspend методов


== Channel
можно туда писать и читать. при чтении лучше, если работаем с "горячими" данными

интерфейсы на чтение и запись. конструктор Channel (такого класса нет, только интерфейс)

можно сделать буфер

можно закрыть канал. у читателей закончится итератор

Если писатели быстрее читателей

* делаем конечный буфер 
* перезаписываем старые данные
* приостанавливаем produce, если можно


produce {...} -- создает НОВУЮ корутину (в отличии от flow), которая читает из какого-то канала

== Акторы 
вместо методов -- сообщения 