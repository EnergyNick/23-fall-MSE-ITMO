= Еще штуки
== Блокировка 

`sync` и `lock` -- нельзя прервать снаружи. Прерываемый -- `lockInterruptibly`.

Тогда зачем `lock` прерываем? 

Как происходит `interrupt`? 

Пусть поток ожидает, как его прервать? 
Нужно вернуть его поток на исполнение (планировщику потоков), протащить через runnable и running.

`tryLock` -- атомарный. 

Кажется, `tryLock` (time) -- бросает, т.к. там есть sleep (нужно посмотреть в библиотете!)
== Condition
От одного lock можно породить сколько угодно conditional 

wait и await можно прерывать. Поэтому можно сделать awaitInterruptibly

Зачем захватывать при wait? Потому что wait и notify завязаны на способ блокирования и объект. Логика похожа на планировщик потоков. Поэтому лучше связать одно с другим.

== ReentrantLock 
Один поток может брать один и тот же объект 


== Паттерн читатели/писатели

* нельзя писать одновременно
* нельзя читать, пока идет запись

Например, изменяемый конфиг

== Управления заданиями

=== Executor(Runnable)
запускает runnable 

* в том же потоке  
* в новом потоке
* пул потоков  (мб наращиваемый)

=== interface Callable<V>

Выполнить задание и вернуть результат типа V

V call

Supplier не может кинуть exception, а callable может.

=== Future 
позволяет отменить выполнение 

=== ExecutorService 
Содержит 1 пользовательский поток. Поэтому его нужно остановить: shutdown прекращает прием задач и завершается, когда выполнить все из очереди.
shutdownNow -- выполнит до конца те, что выполняются сейчас, но не будет брать новые из очереди и завершится

Если не писать shutdown, то программа никогда не закончится.

==== Создание 
Executor.<<вызвать статический метод>>
* newSingleThreadExecutor -- создает на один поток. Например для задач, которые выполняются последовательно. Это дает доп гарантии: блокировки не нужны, работает быстрее.
Часто используется при работе с вводом/выводом.



image::media/executors_2.png[]

Зачем нужен invokeAny?

 Например, когда у нас БД лежит по какому-то из адресов, но по какому точно мы не знаем.


InterruptedException -- кто-то завершил поток извне 

ExecutionException -- поток завершился сам с ошибкой.

=== ScheduledExecutorService
выполнить задачу не 1 раз, а запускать каждые 10 секунд.

== 3 Примитивы синхронизации

=== Семафоры 
Разрешает работать с ресурсами не 1 потоку, а n штук. Аналогия с парковкой.

n -- количество разрешений.
Можно получить разрешение или вернуть его. Один поток может взять несколько разрешений (большая машинка).

Может получится дедлок.

==== Примеры 
1. Потоки. ExecutorService -- нужны, чтобы управлять ресурсами (сколько работников, растут ли они). Не всегда задачу можно оформить так, чтобы поместить ее в ExecutorService (например, у нее есть контекст). Поэтому количество потоков, которые будут одновременно в ОС можно ограничить количеством семафоров (например, количеством ядер процессора). Прои этом семафор можно брать в разных частях системы децентрализовано. Это и минус, т.к. мы управляем памятью не в одном месте, а децентрализовано.
2. Память. Если памяти мало и все потоки одновременно стартанут, то памяти не хватит. Создаем семафоры, которые связаны с досутпной памятью. Поэтому поток должжен просить столько семафоров, сколько отражает его потребность в памяти. В качестве разделяемого ресурса может быть что угодно.
3. Веб сервер: на ПК ограниченное количество портов, та же истрия.

=== Барьер
Аналогия со скачками и лошадками. Лошади ждут у барьера, пока лбом не уткнуться n лошадей. 

сломанный барьер -- когда пришло 5 лошадей и 2 интераптнули. Если барьер ресетнули, то бросается исключение 

arrive == await

В барьер можно положить метод-обработчик, который выполняется в потоке, вместе с которым мы прорвем барьер.

==== Примеры 
Нужен, когда хотим дождаться пока все сделают свою часть. Многопользовательские игры и т.д.

=== Монитор vs mutex 
В Java это одно и то же
Монитор - кондишн и то, по чему мы делаем wait и notify.

=== Защелка 
Пример: засов, который задвинули на несколько сантиметров. Одноразовая. Засов дергают разные сущности (в отличии от барьера). Но одноразовый барьер можно реализовать через засов.Некоторые потоки могут ничего не делать, а только ждать.

Пример: инициализация. Инициализирующие потоки двигают защелки и умирают (или нет). Ожидающие потоки просто ждут, пока защелка откроется.

=== Рандеву 
Возможность атомарно обменяться объектом с одним потоком. Пример: овощебаза и фуры или окно обмена в майнкрафт сервере. Если один объект нужно обработать в разных потоках.

== Атомарные операции
операции, которые мы видим только в состоянии `до` или только в состоянии `после`. 

Атомарные: 
* чтение, запись (атомарные в Java)
* чтение и запись getAndSet 
* условная запись compareAndSet. По дефолту сравниваем со старым значением.

=== cas(0, 1) -- аналог блокировке --  spinLock.
+потоки не уходят в состояние blocking 

-находимся в активном ожидании

Нужно,когда сделать операцию быстрее, чем менять контексты потоков (например, счетчик).

Стандартный лок сначала пробует так, а потом делает нормальные блокировки.

Ленивая запись -- в кеше потока меняет и мб оно когда-нибудь прорастет. Это слабая гарантия.

Зачем атомарная ссылка? Чтобы делать cas.

Атомарные массивы -- общий интерфейс атомарный. 

== Сравнение графиков для inc
1. Честный lock -- хуже всех: каждый раз сменяется поток.
2. sync - побыстрее, но поток все равно вытесняется с ядра. Можно сделать по this, int, по самому методу.
3. Нечестный lock -- побыстрее: операция простая, выигрываем за счет активного ожидания.
4. atomicInteger + inc -- быстрее, так как реализован на активном коде. Внутри него нечестный lock.

Ошибки
1. Нечестный лок не используйте никогда
2. sync всегда лучше lock
3. Всегда используйте atomic

Это все зависит от 

1. Как конкретный метод реализован на конкретном железе
2. Размер критической секции (если она большая, честная блокировка мб лучше, а в средней lock может проигрывать sync)