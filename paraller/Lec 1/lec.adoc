= Параллельное программирование =
Калишенко Евгений, 2023

Системный архитектор. Ассемблер читает со словарём

* Зачет: сдать все лабы (4-5)
* Экзамен: беседа полчаса по практике и теории. На экзамене могут показать ошибку в дз и спросить, ошибка ли она (могут взять на понт).

Дз: дедлайн 1 месяц. 

Считается, что к дедлайну будет закомичен код, который проходит все тесты, кроме, возможно, последнего.

ftp://kel.osll.ru (через браузеры не работает, они не поддерживают. Можно через файловых менеджер)

ftp kel.osll.ru

user: anonymous

logout: bye

Директория hps

Нефункциональное требование: удовлетворить требуемый уровень производительности. Почти не смотрим на распределенные вычисления. В основном работаем на общей памяти.

Работаем с системами, которые генерируют огромное количество информации. Их обработка в реальном времени почти невозможна.

Требования к производительности бывают разные:

* снизить латентность (банковские системы и т.д.)
* посчитать огромный набор данных (астрономия, генетика и т.д.) без привязки ко времени.

== Расширения процессора ==
Одно ядро. Как сделать многопоточность?

Расширение процессора -- добавление доп регистров и инструкций.

SIMD operation -- I - instruction D - data, S - single, M - multiply

SIMD -- обрабатываем много потоков данных (разных) одним потоком инструкций.

* `SSE` -- Streaming SIMD extensions 

Векторизация -- применение векторных инструкций (например, перемножаем два вектора)

В 2008 году добавили в SSE операции со строками, т.к. стали популярны текстовые протоколы взаимодействия (xml, json), сериализации/десериализации

* `AVX` -- advanced vector extensions (на что-то из этого подвязан даже TensorFlow)

Если запустить приложение, но расширения нет -- будет прерывание ОС и окошко (или лог в терминал) "неизвестная инструкция процессора".

* `MMX` -- multimedia (?) extensions -- работа с целыми числами (обработка цветов)

* `FPU` -- floating point unit

*Посмотреть мои расширения: `lscpu`*

image::media/my_extensions.png[]

== Процессы и потоки ==
Процесс -- агрегирующая сущность, имеет хотя бы 1 поток, набор дескрипторов, ресурсов и т.д.

Поток -- выполняется на процессоре 

У процессоров есть отношение предок-потомок (образуют дерево: `pstree`). Корень - systemd (раньше был initd)


1. Запустили калькулятор. Усыпили его и перевели в фоновый режим `bg` (background).
2. Посмотрели текущий `id` процесса интерпретатора, через который мы запустили компилятор. `echo $$`. Проверить: `ps -ax | grep <pid>`.
3. Запустим калькулятор из нового окна консоли (с амперсандом, т.е. в фоновом режиме ~ bg).

 yakuake - выпадающий терминал. И в рамках его видим, сколько процессов запущено в системе (число - арность - сколько запущено). Это доказывает существование отношения предок-потомок между процессами. Т.е. реально вызывается fork -- делает копию процесса из текущего процесса.

4. Убьем второй процесс баша (из которого запускали с амперсандом) `kill -9 <pid>` (флаг 9 посылает сигнал `sigkill`, по умолчанию `sigterm`, который процесс может игнорировать). Теперь процесс баша исчез.
Баш погиб, но его потомка-калькулятора усыновил главный (корневой) процесс. Не предок-предка! А корневой.

 Зомби - процессы, которые не могут умереть, т.к. код их возврата важен какому-то предку.

5. Убьем первый интерпретатор. Его калькулятор тоже повиснет на `systemd`.
6. Запустим калькулятор, остановим (`ctr+Z` -> сигнал `sigstop`, его не поставят на исполнение на ядре процессора), узнаем код текущего процесса и вернем его калькулятор (`fg` ~ `foreground`).  Убьем консоль. Калькулятор убился совсем.

== Поток ==
Есть ли такое у потоков?  

В случае потоков никаких подобных отношений не существует. Поток создался -- и он независим от потока-родителя, который его создал.

В `ftree` запись `68*[{zoom}]` -- означает, что в процессе zoom запущено `68` потоков, не считая основного. Т.е. всего 69.

У потоков есть id, но команды "завершить поток процесса" нет, т.к. это внутреннее дело процесса.

Если подключимся к процессу через `gdb`, то можем узнать информацию о его потоках
`info threads`.

 Почему у systemd есть ребенок systemd? Мы сделали форк корневого процесса, чтобы из него безопасно запускать всякое другое.

== Закон Амдала ==

image::media/amdala.png[]

p - количество процессов 

stem:[alpha] - доля последовательного кода 

stem:[S_p] -- выигрыш в производительности при параллелизме.

==  Потоки ОС (POSIX) ==
`POSIX` -- стандарт, который определяет набор системных вызовов, из сигнатуру и поведение, которые должно поддерживать ядро ОС, чтобы быть posix-совместимой. 

`Posix-threads` --расширение к Posix, чтобы работать с многопоточность (`pthread_*`)

Пока его не было, при `pthread_create` создавался не новый поток, а еще 2 процесса: соседний и родительский.

Java 

Можно создать поток двумя способами

=== 1. Имплементировать интерфейс

```
class Some implements Runnable {

@overide 
run(...)
...
}
```

Передать экземпляр в объект класса thread 

```
Thread t(SomeRunable)
t.start()
```

=== 2. Наследоваться от Thread

```
Some extends Thread {
    override run()
}
```

`-` Тут теряем возможность наследования от другого класса.  

`-` Не можем повторно использовать наши объекты, которые создали для вычислений.

== Степени связности объектов 
*Степени связности объектов* ~~ сколько кода нужно изменить, чтобы разорвать связность объектов. Указаны в порядке убывания.

1. Дружественность (`friend`). Самая сильная степень связности, т.к. имеем доступ к private  полям.
2. Наследование (не зависим от private полей и методов).
3. Композиция (время жизни родителя такое же, как у ребенка: завязаны на время жизни объекта). 
4. Агрегация (можем создавать объекты в разных местах приложения и связывать их).

Композиция и агрегация -- дети ассоциации

Связи бывают:

* `Неинтрузивные` -- пользуемся только публичным интерфейсом. 
* `Интрузивное` -- проникаем в непубличные внутренности. Интрузивные указатели в `C++` умные указатели, когда передаем извне специфический (например, для ОС) способ подсчета ссылок.

== Многопоточное vs многопроцессное

Процессы IPС - механизмы обмена данными между процессами

* `pipe` (специфичный для ОС механизм -- виртуальный файл, очередь где мы в режиме `FIFO` можем общаться между процессами (обычно двумя). Могут быть именованными или нет (тогда используем дескриптор)).
* `shmem` -- shared mem -- предполагает, что между двумя и более процессами выделяется участок общей ОП (между всеми потоками разных процессов).
* `socket` -- общение по сети или в рамках одной машины (unix-socket). От pipe отличается тем, что в общем случае работаем именно в терминах сетевого взаимодействия: общаемся через дескрипторы сетевых портов, имеем меньше технических ограничений
* `file` --  синхронизирован на уровне ОС. Может быть отркрыт многими пользователями.
* `signal` -- отличаются от всех остальных 
 1. По природе асинхронный. Подписываемся на `callback`.
 2. Не можем передавать данные при этом способе взаимодействия. Только сообщить, что что-то произошло.

синхронный -- 

асинхронный -- не можем предсказать или ожидать, когда мы будем обрабатывать входящие данные, после какой строчки кода. Они всегда стресс. 

`dd if=/dev/zero of=/dev/null` -- копирует генерируемые нули в пустоту.

`dd` -- копирование низкоуровневое

`if` -- input file 

`kill SIGUSR1 <pid>`

`SIGUSR1` -- никакой сигнал. Пользовательский, можем придумать какую-то логику для пользовательских сообщений.

Всего их 2.
 
Если отправить процессу сигнал, на который у него нет обработчика -- он умрет (аналог `SIGTERM` -- `Ctr + C`).

`fork` --  вызывается внутри потока, но копирует весь процесс.

`ulimit -a` -- лимиты пользователя, которые установлены для данной консоли, например (в рамках процесса)


glibc