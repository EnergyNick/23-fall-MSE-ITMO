= Атомарные snapshot 
 Поможет сделать метод итератор во второй домашке 

Есть набор атомарных регистров. Это просто ячейка в памяти. 

 Исторически сложилось, что ячейка памяти для записи и чтения называется регистром. Этот объект никак не связан в регистрами машин.

== Как писать в регистр любое количество данных атомарно? 
Есть структура X 

и глобальный экземпляр этой структуры. Как поменять значение в ней? 

Копируем структуру, меняем поле, через cas меняем структуру обратно.

```
X* a;
b = *a;
b.val = new_val;
cas(a, prev_a, &b);
```

== Задача: в lockfree стиле реализовать алгоритм снятия снепшота атомарных регистров.

Снепшот -- набор из значений регистра. Должен быть 

* согласован -- набор значений должен хотя бы когда-то существовать в одно мгновение в системе. Чтобы система принимала согласованные решение на их основании.
* актуален -- то значение, которое обязательно было после момента начала вызова метода `make_snapshot`. Изначально регистры нулевые. Это согласованное значение, но нам не подходит.

=== 1. Добавим в регистр версию. 
Считываем, пока два вектора (набора) версий не станут одинаковыми. 

```c++
void scan(){
    a = collect(regs)
    b = collect(regs)
    if (a == b)
        return a;
    // repeat
}
```

lockfree ли он? Да 

`-` писателей в регистры "больше прав", чем у читателя-scan.

`+` что засыпание процесса -- треубет порядка 10^3 тактов процессора. Прочитать 10-100 регистров быстрее.

`+` данные более актуальны, т.к. у писателей больше прав.


== Unbounded wait free  
unbounded -- т.е. размер версий неограничен

хочу гарантировать, что писатель и читатель завершит свою задачу за n шагов, который зависит только от размера данных, а не от количества читателей/писателей.

Ограничение: каждый регистр -- Single writer/ multiple reader
```c++
void update(int reg, T data){
    snapshot s = scan();
    //тут могут пройти годы
    write(reg, data, v++, s);
}
```

```c++
void scan(){
    r1 = read(regs);
    r2 = read(regs);
    if(r1.v == r2.v) 
        return r1;
    //иначе было событие-записи
    //значит где-то между ними мы сделали снепшот
    //проблема в том, мы могли начинать делать снепшот до вызова нашего scan
    r3 = read(regs);

}
```

К нас есть n регистров 

Писатель: снимает снепшот и пишет в регистр, который меняем. 

image::media/swmr_snapshot.png[]

Когда снимаем снепшот -- итеративно сраниваем версии. Если они совпадают -- возвращщаем результат. Иначе детектируем какой именно регистр изменялся. Если какой-то регистр записывался второй раз, значит он начал записывать snapshot после начала нашего scan и значение актуальны. Можем вернуть значение snapshot из этого регистра.

Актуально, т.к. single writer.

`-` квадратичная память

`-` долгая запись 

Зачем такие алгоритмы нужны? Планировщики ОС жеского реального времени для ответственного применения (АЭС, самолеты и т.д.). Такой подход гарантирует, что если какой-то сигнал приходит, то можно гарантировать время отклика. 

ОС мягкого реального времени -- в среднем гарантия на обработку внешего воздействия тоже есть, но не всегда. В жестком реальном времени задержек точно не будет.

Любой lock free алгоритм формально можно преобразовать в wait free. Но формально не значит реализуемо. Как: потоки публикуют свои операции и помогают друг другу выполняться. Но это требует гораздо больше памяти и не всегда реализуемо на практике.

=== bounded 
Заменяем поле версии на битовый handshake, т.к. нам нужна не  сама версия, а просто признак того, что произошли изменения.

== Multi Writer MR
Данные и id потока, который сделал последнюю запись в регистр. Выделяем еще один регистр для каждого писателя, где-то хранится его snapshot.

Мы разделили сущность на две и теперь у нас на порядок больше проблем!!! 

Одно изменение сначала будет записан в snapshot, а потом в данные регистра. Или наоборот. Проблема в том, что это не атомарная операция.

Чтобы выгресть эту разницу в худшем случае наблюдает изменение регистра не два раза, а три. Могла быть ситуация, когда мы одну запись наблюдали дважды в разных регистрах.

Мы смотрим регистры не всех n потоков со snapshot, а только тех, чей id записан в регистр данных.

=== Wait free  

`-`  много памяти 

`-` ниже средняя производительность 

`+` ОС жесткого реального времени


Во второй лабе нужно предоставлять в итераторе согласованное состояние.

Во второй лабе не ожидают: пусть есть идеально реализованный hashset. Все операции реализовываем, делая его atomic reference 

```c++
void push_back(){
    hs x = s.clone();
    x.push_back();
    s.cas(...)
}
```

Потому что это крайне низкопроизводительно. Поэтому и персистентная структура данных может не пройти. Но если очищать что надо когда надо, то может и пройти.

