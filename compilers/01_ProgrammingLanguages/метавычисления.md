# Метавычисления 
Язык программирования `L` -- множество программ (не более, чем счетное множество объектов).

Семантика ЯП -- смысл программы, который зависит от языка. 

[.] -- обозначение семантики

D - семантический домен 

[.] : L |-> D  

Семантика -- всюду определенное отображение языка программирования в семантический домен.

### Пример 1
D - множество частично рекурсивных функций

L - язык, который его задает (+-1, проекция, суперпозиция)



### Пример 2
D - натуральные числа N

A = '0', '1', ...'9'  
L = {A}+  
[e] = 0  
???

Часто мы хотим, чтобы D -- было пространством функций и отображало входные данные в выходные.

Для функций высших порядков 

D >= D -> D

D >= L для метавычислений

D > D x D  содержит все элементарные данные + двойки + тройки + четверки...


L, [.], D (функция)

int[L][M] -- интерпретатор языка L,  программа которая написана на языке M.   
[.]_M : M -> D  
### Уравнение интерпретатора
[int [L][M]](P_)   

int [L][M] -- программа на языке М

[] - функция из входных данных в выходные

P_l - программа L как синтаксический объект


x - входные данные (элемент данных)

картинка 2

картинка 1


Интерпретатор является универсальной функций. 

Частично рекурсивные функции - часть всех задач (всюду определенных функций), которые выполняются на машине тьюринга. Для них не существует общерекурсивной универсальной функции.

Нормализация -- завершаемость -- приход к нормальной форме (не к бета-нормальной форме).

Автоинтерпетатор -- написан сам на себе. Может не существовать (н-р для чатсинчо рекурсивных)

Интерпретаор - языковой процессов -- воспринимает язык как данные 

spec_m^l - специализатор
## уравнение специализатора
$[[spec_M^L](p_L, x)]_Ly = [P_L]_L(x, y)$

картинка 3

частичное применение принимает программу от двух аргументов и первый аргумент. Возвращает код программы с примененным первым аршументом (мю оптимизированным). Результат выполнения программы ко второму аргументу такой же, как если бы исходной программе передали сразу два аргумента. 

Специализированная программа -- то, что выдает специализатор.

## Проекции Футамуры
1. Получаем компилятор как фукнцию

 Возьмем специализатор L написанный на М и интерпретатор, написанный на L, который интерпретирует язык K,вход - программа на языке К. Эта штука ожидает входные данные для программы на к - х
картинка 


первое -- это программа на языке L, которая примененная к  х

специализация интерпретатора на программу дает код этой программы на языке интерпретатора 

Используется в GraalVM для раскрутки (Truffel)

2. Получаем код компилятора

специализируем специаализатор 
$[[spec^M_P](spec_M^L, int_l^k)]_MP_k = [spec_M^L]_M(int^k_L, p_k)$ -- то что справо в я зыке Л

программа на языке М берет код на языке К и возвращает эквивалентный код на языке Л -- это компилятор

3. дает код генератора компиляторов

Генератов компиляторов 

$[[spec_s^P]_s(spec_p^M, spec_M^L)]_pint_l^k = [spec_p^m]_p(spec_m^l,int_l^k)$ 

