# Введение в PL, компиляторы и инструменты
Дмитрий Булычев  
dboulytchev@gmail.com  
@senormouse

* PL - progrsmming languages
* Compilers and Tools


Статься Reimplementing the Wheel обосновывает почему курс именно такой.

Пишем Lama на Lama (в других курсах нет модельных языков, компиляторы которых пишут на них самих).

## История Lama
* Fortran (~1957) один из первых языков общего назначения
* Algol -> 60 ->  68 в свое время был типа как хаскель сейчас

Lama -> **Lam**bda **A**lgol

* не типизированный (это чтобы поймать интересные ошибки и посмотреть, как делать не надо)
* чтобы вводить типы нужно добавлять полиморфизм, вывод типов, и т.д. и т.п. Это очень сложно и замах еще на 1 курс.
* `value restriction` (из систем с `let` полиморфизмом) и другие вещи мешают смотреть прикольные штуки.   
`let a = []` -- тип элемента списка неизвестен      
$\alpha~List~res$    
`let _ a := [1], let _ a := ['l']` -- тут все поломается. Мы решили, что а - инт, а потом передумали и получили ошибку.   
$\forall \alpha.\alpha~List~res$    


У нас есть `Lama`, реализованная на `OCaml` и на `Lama`. Но второй пока работает не очень, поэтому используем для работу реализацию на `OCaml`.

Целевая платформа: x86/32

Собирается под Linux

Все команды на Lama сначала генерируются в код абстрактной стековой машины, который затем транслируется в инструкции x86

Функции 
* все высших порядков
* можно использовать безымянными и объявлять там, где нужны
* можно класть функции в структуры данных


Структуры данных
* любую можно напечатать `obj.string`

S-выражения 
* рантаймовое представление алгебраических типов данных

Из нее можно дергать функции `libc`

Язык императивный (перемнные, изменяемые состояния и т.д.). Но можно писать и функционально.

## Операционная семантика
Семантика, описанная формально. Её нужно изучить, т.к. неформальных знаний о языке недостаточно, чтобы реализовать любой транслятор. Наши знания о языках будут refined -- уточняться и улучшаться. Именно поэтому мы пишем  компилятор языка на нем самом.

## Способы реализации программной системы
1. `Горизонтальный` -- программа представляет из себя иерархию уровней. Идем по уровням снизу вверх, реализуя их в полном объёме.  
Применяется в промышленном коде.   
Если мы будем делать так, то до конца семестра реализуем примерно полтора уровня.
2. `Вертикальный` -- берем какую-то фичу и пилим ее до конца. 

Мы при реализации компилятора используем вертикальный. Бывают не инкрементальные изменения и придется изменять, т.к. изменится семантика. На 16 недель будет 9-10 домашек.   
На каждый этап есть набор тестов. Такой подход позволит изолировать ошибки разных уровней друг от друга.


## Домашние работы 
